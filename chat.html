<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC PeerJS Chat</title>
    
    <!-- Resource optimization: preload critical resources -->
    <link rel="preload" href="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js" as="script">
    <link rel="dns-prefetch" href="//unpkg.com">
    <link rel="dns-prefetch" href="//0.peerjs.com">
    <link rel="dns-prefetch" href="//stun.l.google.com">
    <style>
        /* Modern CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --secondary-color: #6c757d;
            --light-bg: #f8f9fa;
            --white: #ffffff;
            --border-color: #dee2e6;
            --text-color: #333;
            --text-muted: #6c757d;
            --border-radius: 8px;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
            --transition: all 0.3s ease;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-color);
            line-height: 1.6;
        }
        
        /* Mobile-first responsive container */
        .container {
            background: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            max-width: 100%;
            margin: 0 auto;
            transition: var(--transition);
        }
        
        /* Tablet styles */
        @media (min-width: 768px) {
            body {
                padding: 2rem;
            }
            
            .container {
                padding: 2rem;
                max-width: 600px;
            }
        }
        
        /* Desktop styles */
        @media (min-width: 1024px) {
            .container {
                max-width: 800px;
                padding: 2.5rem;
            }
        }
        
        /* Modern browser upgrade warning styles */
        .browser-warning {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 2rem;
            text-align: center;
        }
        
        .browser-warning-content {
            max-width: 600px;
            background: var(--white);
            color: var(--text-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .browser-warning h2 {
            color: var(--danger-color);
            margin-bottom: 1rem;
        }
        
        .browser-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .browser-link {
            display: block;
            padding: 1rem;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: var(--border-radius);
            transition: var(--transition);
            text-align: center;
        }
        
        .browser-link:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
        }
        
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: var(--text-color);
            text-align: center;
            margin-bottom: 2rem;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Modern CSS Grid layout for sections */
        .sections-grid {
            display: grid;
            gap: 1.5rem;
            grid-template-columns: 1fr;
        }
        
        @media (min-width: 768px) {
            .sections-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .section.chat-section {
                grid-column: 1 / -1;
            }
        }
        
        .section {
            background: var(--light-bg);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            transition: var(--transition);
        }
        
        .section:hover {
            box-shadow: var(--shadow);
            transform: translateY(-2px);
        }
        
        .section h3 {
            margin: 0 0 1rem 0;
            color: var(--text-color);
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        /* Modern form controls using CSS Grid and Flexbox */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        @media (min-width: 480px) {
            .form-group.inline {
                flex-direction: row;
                align-items: center;
            }
            
            .form-group.inline input {
                flex: 1;
            }
        }
        
        input, button, textarea {
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-family: inherit;
            transition: var(--transition);
            background: var(--white);
        }
        
        input:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }
        
        button {
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            border: 2px solid var(--primary-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 44px; /* Touch-friendly minimum */
        }
        
        button:hover:not(:disabled) {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
            transform: translateY(-1px);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #chat-log {
            width: 100%;
            min-height: 200px;
            height: 40vh;
            max-height: 400px;
            resize: vertical;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            background: var(--white);
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        
        #my-id {
            font-weight: 600;
            color: var(--success-color);
            padding: 0.75rem;
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border-radius: var(--border-radius);
            border: 2px solid #b8dacc;
            font-family: 'SF Mono', Monaco, monospace;
            word-break: break-all;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .test-results {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .test-pass {
            color: #28a745;
        }
        
        .test-fail {
            color: #dc3545;
        }
        
        .connection-status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            background-color: #f8f9fa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-indicator {
            font-size: 12px;
            font-weight: bold;
        }
        
        .status-disconnected {
            color: #6c757d;
        }
        
        .status-connecting {
            color: #ffc107;
            animation: pulse 1.5s infinite;
        }
        
        .status-connected {
            color: #28a745;
        }
        
        .status-error {
            color: #dc3545;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .retry-btn {
            background-color: #17a2b8;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .retry-btn:hover {
            background-color: #138496;
        }
        
        .connection-progress {
            margin-top: 10px;
            padding: 8px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #dee2e6;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .network-diagnostics {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
        }
        
        .network-diagnostics h4 {
            margin: 0 0 8px 0;
            color: #856404;
            font-size: 14px;
        }
        
        .diagnostic-item {
            margin: 4px 0;
            font-size: 12px;
            color: #856404;
        }
        
        .diagnostic-success {
            color: #155724;
        }
        
        .diagnostic-warning {
            color: #856404;
        }
        
        .diagnostic-error {
            color: #721c24;
        }
        
        .performance-metrics {
            margin-top: 10px;
            padding: 10px;
            background-color: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 4px;
        }
        
        .performance-metrics h4 {
            margin: 0 0 8px 0;
            color: #0c5460;
            font-size: 14px;
        }
        
        .metric-item {
            margin: 4px 0;
            font-size: 12px;
            color: #0c5460;
            display: flex;
            justify-content: space-between;
        }
        
        .metric-value {
            font-weight: bold;
        }
        
        .metric-good {
            color: #155724;
        }
        
        .metric-warning {
            color: #856404;
        }
        
        .metric-poor {
            color: #721c24;
        }
        
        .connection-quality {
            margin-top: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .quality-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .quality-excellent {
            background-color: #28a745;
        }
        
        .quality-good {
            background-color: #ffc107;
        }
        
        .quality-poor {
            background-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC PeerJS Chat</h1>
        
        <div class="sections-grid">
            <div class="section">
                <h3>Your Peer ID</h3>
                <div id="my-id">Connecting...</div>
            </div>
            
            <div class="section">
                <h3>Connect to Peer</h3>
                <div class="form-group inline">
                    <input type="text" id="peer-id-input" placeholder="Enter peer ID to connect" autocomplete="off">
                    <button id="connect-btn">Connect</button>
                </div>
            <div id="connection-status" class="connection-status">
                <span id="status-indicator" class="status-indicator">●</span>
                <span id="status-text">Disconnected</span>
                <button id="retry-btn" class="retry-btn" style="display: none;">Retry</button>
            </div>
            <div id="connection-progress" class="connection-progress" style="display: none;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div id="progress-text">Connecting...</div>
            </div>
            <div id="network-diagnostics" class="network-diagnostics" style="display: none;">
                <h4>Network Diagnostics</h4>
                <div id="diagnostic-info"></div>
            </div>
            <div id="performance-metrics" class="performance-metrics" style="display: none;">
                <h4>Performance Metrics</h4>
                <div id="performance-info"></div>
            </div>
            <div id="connection-quality" class="connection-quality" style="display: none;">
                <h4>Connection Quality</h4>
                <div id="quality-info"></div>
            </div>
            </div>
            
            <div class="section chat-section">
                <h3>Chat</h3>
                <textarea id="chat-log" readonly placeholder="Chat messages will appear here..." aria-label="Chat messages"></textarea>
                <div class="form-group inline">
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" aria-label="Message input">
                    <button id="send-btn" disabled>Send</button>
                </div>
            </div>
        </div>
        
        <div class="test-results">
            <h3>Test Results</h3>
            <div id="test-output"></div>
        </div>
    </div>

    <!-- Simple Testing Framework (Jest-lite was causing issues) -->
    
    <!-- PeerJS Library - optimized loading -->
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js" defer></script>
    
    <script>
        // ===== MODERN BROWSER DETECTION AND BLOCKING =====
        
        /**
         * Detects browser version and blocks legacy browsers
         * Supports Chrome 88+, Firefox 85+, Safari 14+ only
         */
        const detectAndBlockLegacyBrowsers = () => {
            const userAgent = navigator.userAgent;
            const browserInfo = getBrowserInfo(userAgent);
            
            if (!browserInfo.isSupported) {
                showBrowserUpgradeWarning(browserInfo);
                return false;
            }
            
            // Log browser info for deployment analysis
            console.log('✅ Modern browser detected:', browserInfo);
            return true;
        };
        
        /**
         * Parses user agent to determine browser and version
         * @param {string} userAgent - The navigator.userAgent string
         * @returns {Object} Browser information with support status
         */
        const getBrowserInfo = (userAgent) => {
            // Modern browser detection using regex patterns
            const browsers = [
                {
                    name: 'Chrome',
                    pattern: /Chrome\/(\d+)/,
                    minVersion: 88,
                    downloadUrl: 'https://www.google.com/chrome/'
                },
                {
                    name: 'Firefox',
                    pattern: /Firefox\/(\d+)/,
                    minVersion: 85,
                    downloadUrl: 'https://www.mozilla.org/firefox/'
                },
                {
                    name: 'Safari',
                    pattern: /Version\/(\d+).*Safari/,
                    minVersion: 14,
                    downloadUrl: 'https://www.apple.com/safari/'
                },
                {
                    name: 'Edge',
                    pattern: /Edg\/(\d+)/,
                    minVersion: 88,
                    downloadUrl: 'https://www.microsoft.com/edge'
                }
            ];
            
            for (const browser of browsers) {
                const match = userAgent.match(browser.pattern);
                if (match) {
                    const version = parseInt(match[1], 10);
                    return {
                        name: browser.name,
                        version,
                        minVersion: browser.minVersion,
                        isSupported: version >= browser.minVersion,
                        downloadUrl: browser.downloadUrl,
                        userAgent
                    };
                }
            }
            
            // Unknown browser - block by default
            return {
                name: 'Unknown',
                version: 0,
                minVersion: 999,
                isSupported: false,
                downloadUrl: 'https://www.google.com/chrome/',
                userAgent
            };
        };
        
        /**
         * Shows browser upgrade warning with download links
         * @param {Object} browserInfo - Browser information object
         */
        const showBrowserUpgradeWarning = (browserInfo) => {
            const warningHtml = `
                <div class="browser-warning">
                    <div class="browser-warning-content">
                        <h2>🚫 Modern Browser Required</h2>
                        <p><strong>Your browser is not supported.</strong></p>
                        <p>Detected: ${browserInfo.name} ${browserInfo.version || 'Unknown'}</p>
                        <p>This application requires modern browser features and will not work with legacy browsers.</p>
                        
                        <h3>Minimum Requirements:</h3>
                        <ul style="text-align: left; display: inline-block;">
                            <li>Chrome 88+ (Released Jan 2021)</li>
                            <li>Firefox 85+ (Released Jan 2021)</li>
                            <li>Safari 14+ (Released Sep 2020)</li>
                            <li>Edge 88+ (Released Jan 2021)</li>
                        </ul>
                        
                        <p><strong>Why upgrade?</strong> This app uses modern JavaScript (ES2020+), WebRTC, and CSS features that require recent browser versions for security and performance.</p>
                        
                        <div class="browser-links">
                            <a href="https://www.google.com/chrome/" class="browser-link" target="_blank">
                                Download Chrome
                            </a>
                            <a href="https://www.mozilla.org/firefox/" class="browser-link" target="_blank">
                                Download Firefox
                            </a>
                            <a href="https://www.microsoft.com/edge" class="browser-link" target="_blank">
                                Download Edge
                            </a>
                        </div>
                        
                        <p style="margin-top: 2rem; font-size: 0.9rem; color: #666;">
                            <strong>Mobile users:</strong> Update your browser through your device's app store.
                        </p>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', warningHtml);
            
            // Prevent any further script execution
            throw new Error('Legacy browser blocked');
        };
        
        /**
         * Validates modern JavaScript features are available
         * Tests ES2020+ features like optional chaining, nullish coalescing
         */
        const validateModernJSFeatures = () => {
            try {
                // Test optional chaining
                const test1 = {}?.nonexistent?.property;
                
                // Test nullish coalescing
                const test2 = null ?? 'default';
                
                // Test BigInt
                const test3 = BigInt(123);
                
                // Test Promise.allSettled (ES2020)
                const test4 = Promise.allSettled([Promise.resolve(1)]);
                
                // Test String.matchAll (ES2020)
                const test5 = 'test'.matchAll(/t/g);
                
                console.log('✅ Modern JavaScript features validated');
                return true;
            } catch (error) {
                console.error('❌ Modern JavaScript features not supported:', error);
                showBrowserUpgradeWarning({
                    name: 'Legacy',
                    version: 'Unknown',
                    isSupported: false
                });
                return false;
            }
        };
        
        /**
         * Validates modern WebRTC and browser APIs
         */
        const validateModernWebAPIs = () => {
            const requiredAPIs = [
                'RTCPeerConnection',
                'RTCDataChannel',
                'fetch',
                'Promise',
                'Map',
                'Set',
                'WeakMap',
                'Symbol',
                'Proxy'
            ];
            
            const missingAPIs = requiredAPIs.filter(api => !(api in window));
            
            if (missingAPIs.length > 0) {
                console.error('❌ Missing required APIs:', missingAPIs);
                showBrowserUpgradeWarning({
                    name: 'Legacy',
                    version: 'Unknown',
                    isSupported: false
                });
                return false;
            }
            
            console.log('✅ Modern Web APIs validated');
            return true;
        };
        
        // Run browser detection immediately - block legacy browsers
        if (!detectAndBlockLegacyBrowsers() || !validateModernJSFeatures() || !validateModernWebAPIs()) {
            // Script execution stops here for legacy browsers
            throw new Error('Legacy browser blocked - script execution terminated');
        }
        
        // ===== TESTING FRAMEWORK SETUP =====
        
        // Simple test framework setup - modernized for ES6+
        const testResults = [];
        let testOutput;
        let asyncTestsCompleted = 0;
        let totalAsyncTests = 0;
        
        const describe = (description, testSuite) => {
            console.log(`\n=== ${description} ===`);
            testSuite();
        };
        
        const test = (description, testFunction) => {
            try {
                testFunction();
                testResults.push({ description, status: 'PASS', error: null });
                console.log(`✓ ${description}`);
            } catch (error) {
                testResults.push({ description, status: 'FAIL', error: error.message });
                console.log(`✗ ${description}: ${error.message}`);
            }
        };
        
        const asyncTest = (description, testFunction, timeout = 5000) => {
            totalAsyncTests++;
            setTimeout(() => {
                try {
                    testFunction();
                    testResults.push({ description, status: 'PASS', error: null });
                    console.log(`✓ ${description}`);
                } catch (error) {
                    testResults.push({ description, status: 'FAIL', error: error.message });
                    console.log(`✗ ${description}: ${error.message}`);
                }
                asyncTestsCompleted++;
                if (asyncTestsCompleted === totalAsyncTests) {
                    displayTestResults();
                }
            }, timeout);
        };
        
        const expect = (actual) => ({
            toBe: (expected) => {
                if (actual !== expected) {
                    throw new Error(`Expected ${expected}, but got ${actual}`);
                }
            },
            toBeNull: () => {
                if (actual !== null) {
                    throw new Error(`Expected null, but got ${actual}`);
                }
            },
            not: {
                toBeNull: () => {
                    if (actual === null) {
                        throw new Error(`Expected not null, but got null`);
                    }
                }
            },
            toBeTruthy: () => {
                if (!actual) {
                    throw new Error(`Expected truthy value, but got ${actual}`);
                }
            },
            toContain: (expected) => {
                if (!actual.includes(expected)) {
                    throw new Error(`Expected "${actual}" to contain "${expected}"`);
                }
            }
        });
        
        const displayTestResults = () => {
            testOutput = testOutput || document.getElementById('test-output');
            if (!testOutput) return;
            
            const passCount = testResults.filter(r => r.status === 'PASS').length;
            const failCount = testResults.filter(r => r.status === 'FAIL').length;
            
            const html = `
                <strong>Tests: ${passCount} passed, ${failCount} failed</strong><br><br>
                ${testResults.map(result => {
                    const className = result.status === 'PASS' ? 'test-pass' : 'test-fail';
                    const icon = result.status === 'PASS' ? '✓' : '✗';
                    const errorText = result.error ? ` - ${result.error}` : '';
                    return `<div class="${className}">${icon} ${result.description}${errorText}</div>`;
                }).join('')}
            `;
            
            testOutput.innerHTML = html;
        };
        
        // ===== HTTPS AND SECURE CONTEXT TESTS =====
        
        describe('HTTPS and Secure Context Tests', () => {
            test('should detect if running in secure context', () => {
                expect(typeof window.isSecureContext).toBe('boolean');
            });
            
            test('should have HTTPS protocol when deployed', () => {
                // This test will pass in HTTPS environments and provide info in HTTP
                const protocol = window.location.protocol;
                if (protocol === 'https:') {
                    expect(protocol).toBe('https:');
                } else {
                    // For local testing, just verify we can detect the protocol
                    expect(protocol).toBe('http:');
                }
            });
            
            test('should have WebRTC APIs available in secure context', () => {
                if (window.isSecureContext) {
                    expect(typeof RTCPeerConnection).toBe('function');
                    expect(typeof RTCDataChannel).toBe('function');
                } else {
                    // In non-secure contexts, APIs might be limited
                    console.warn('Running in non-secure context - WebRTC APIs may be limited');
                }
            });
        });
        
        // ===== INITIAL FAILING TESTS =====
        
        describe('DOM Element Existence Tests', () => {
            test('should have my-id element', () => {
                const element = document.getElementById('my-id');
                expect(element).not.toBeNull();
            });
            
            test('should have peer-id-input element', () => {
                const element = document.getElementById('peer-id-input');
                expect(element).not.toBeNull();
            });
            
            test('should have connect-btn element', () => {
                const element = document.getElementById('connect-btn');
                expect(element).not.toBeNull();
            });
            
            test('should have chat-log element', () => {
                const element = document.getElementById('chat-log');
                expect(element).not.toBeNull();
            });
            
            test('should have message-input element', () => {
                const element = document.getElementById('message-input');
                expect(element).not.toBeNull();
            });
            
            test('should have send-btn element', () => {
                const element = document.getElementById('send-btn');
                expect(element).not.toBeNull();
            });
        });
        
        describe('Basic Structure Tests', () => {
            test('should have correct page title', () => {
                expect(document.title).toBe('WebRTC PeerJS Chat');
            });
            
            test('should have main heading', () => {
                const heading = document.querySelector('h1');
                expect(heading).not.toBeNull();
                expect(heading.textContent).toContain('WebRTC PeerJS Chat');
            });
            
            test('should have send button initially disabled', () => {
                const sendBtn = document.getElementById('send-btn');
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should have chat-log as textarea', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.tagName.toLowerCase()).toBe('textarea');
            });
            
            test('should have peer-id-input as input field', () => {
                const peerInput = document.getElementById('peer-id-input');
                expect(peerInput.tagName.toLowerCase()).toBe('input');
            });
        });
        
        describe('CSS and Styling Tests', () => {
            test('should have basic styling applied', () => {
                const body = document.body;
                const computedStyle = window.getComputedStyle(body);
                expect(computedStyle.fontFamily).toContain('Arial');
            });
            
            test('should have container with proper styling', () => {
                const container = document.querySelector('.container');
                expect(container).not.toBeNull();
                const computedStyle = window.getComputedStyle(container);
                expect(computedStyle.backgroundColor).toBe('rgb(255, 255, 255)');
            });
        });
        
        describe('External Library Tests', () => {
            test('should have PeerJS library loaded', () => {
                expect(typeof Peer).toBe('function');
            });
        });
        
        // ===== HTTPS ERROR HANDLING FUNCTIONS =====
        
        // Modern browser-optimized HTTPS and WebRTC support functions
        const checkSecureContext = () => {
            if (!window.isSecureContext) {
                addSystemMessage('⚠️ Warning: Running in non-secure context. WebRTC functionality may be limited.');
                addSystemMessage('💡 For full functionality, access this application via HTTPS.');
                return false;
            }
            return true;
        };
        
        const checkWebRTCSupport = () => {
            // Modern browsers have native WebRTC support
            if (!window.isSecureContext && window.location.protocol === 'http:') {
                addSystemMessage('🔒 WebRTC requires HTTPS in production environments.');
                addSystemMessage('💡 This application will work fully when deployed to GitHub Pages (HTTPS).');
                showHTTPFallbackMessage();
            }
            
            return true;
        };
        
        const showHTTPFallbackMessage = () => {
            addSystemMessage('');
            addSystemMessage('🌐 HTTPS Deployment Information:');
            addSystemMessage('📍 GitHub Pages URL: https://mehrmorgen.github.io/CanChat/chat.html');
            addSystemMessage('🚀 For full WebRTC functionality, access the application via HTTPS.');
            addSystemMessage('🔧 Local HTTPS testing: Run python3 test_https_server.py');
            addSystemMessage('');
        };
        
        const detectWebRTCBlocking = () => {
            // Modern browsers support WebRTC natively - simplified blocking detection
            try {
                const testPeer = new RTCPeerConnection();
                testPeer.close();
                return false; // Not blocked
            } catch (error) {
                if (error.message.includes('secure') || error.message.includes('https')) {
                    addSystemMessage('🚫 WebRTC is blocked due to non-HTTPS context.');
                    addSystemMessage('🔒 Modern browsers block WebRTC over HTTP for security.');
                    showHTTPFallbackMessage();
                    return true;
                }
                return false;
            }
        };
        
        const validateHTTPSResources = () => {
            const scripts = document.querySelectorAll('script[src]');
            const nonSecureResources = [...scripts]
                .map(script => script.src)
                .filter(src => src.startsWith('http://'));
            
            if (nonSecureResources.length > 0) {
                nonSecureResources.forEach(src => 
                    addSystemMessage(`⚠️ Warning: Non-HTTPS resource detected: ${src}`)
                );
                return false;
            }
            
            addSystemMessage('✅ All external resources are using HTTPS.');
            return true;
        };
        
        const handleHTTPSError = (error) => {
            const { message } = error;
            
            if (message?.includes('secure')) {
                addSystemMessage(`🔒 HTTPS Error: ${message}`);
                addSystemMessage('💡 This error typically occurs when WebRTC is used over HTTP.');
                addSystemMessage('💡 Deploy to GitHub Pages (HTTPS) for full functionality.');
            } else if (message?.includes('network')) {
                addSystemMessage(`🌐 Network Error: ${message}`);
                addSystemMessage('💡 Check your internet connection and firewall settings.');
            } else {
                addSystemMessage(`❌ Error: ${message}`);
            }
        };
        
        // ===== PEERJS INITIALIZATION TESTS =====
        
        describe('PeerJS Initialization Tests', () => {
            test('should initially display "Connecting..." in my-id element', () => {
                const myIdElement = document.getElementById('my-id');
                expect(myIdElement.textContent).toBe('Connecting...');
            });
            
            test('should have empty chat log initially', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.value).toBe('');
            });
            
            test('should have helper functions defined', () => {
                expect(typeof addSystemMessage).toBe('function');
                expect(typeof updateMyId).toBe('function');
                expect(typeof initializePeer).toBe('function');
            });
            
            test('addSystemMessage function should work correctly', () => {
                const chatLog = document.getElementById('chat-log');
                const initialValue = chatLog.value;
                addSystemMessage('Test message');
                expect(chatLog.value).toContain('System: Test message');
                expect(chatLog.value.length).toBe(initialValue.length + 'System: Test message\n'.length);
            });
            
            test('updateMyId function should work correctly', () => {
                const myIdElement = document.getElementById('my-id');
                updateMyId('test-id-123');
                expect(myIdElement.textContent).toBe('test-id-123');
                expect(window.myId).toBe('test-id-123');
                // Reset for other tests
                myIdElement.textContent = 'Connecting...';
                window.myId = null;
            });
        });
        
        // ===== ASYNC PEERJS TESTS =====
        
        describe('PeerJS Async Behavior Tests', () => {
            asyncTest('should create PeerJS instance after initialization', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer instanceof Peer).toBe(true);
            }, 1000);
            
            asyncTest('should configure PeerJS with Google STUN server', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer._options).not.toBeNull();
                expect(window.peer._options.config).not.toBeNull();
                expect(window.peer._options.config.iceServers).not.toBeNull();
                expect(window.peer._options.config.iceServers.length).toBe(1);
                expect(window.peer._options.config.iceServers[0].urls).toBe('stun:stun.l.google.com:19302');
            }, 1000);
            
            asyncTest('should update peer ID display when ready', () => {
                const myIdElement = document.getElementById('my-id');
                // Should no longer show "Connecting..." after peer is ready
                expect(myIdElement.textContent).not.toBe('Connecting...');
                expect(myIdElement.textContent.length).toBe(16); // PeerJS generates 16-character IDs
            }, 3000);
            
            asyncTest('should add system message when peer ID is ready', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
            }, 3000);
            
            asyncTest('should set global myId variable when ready', () => {
                expect(window.myId).not.toBeNull();
                expect(typeof window.myId).toBe('string');
                expect(window.myId.length).toBe(16);
            }, 3000);
        });
        
        // ===== HTTPS DEPLOYMENT SPECIFIC TESTS =====
        
        describe('HTTPS Deployment Validation Tests', () => {
            asyncTest('should validate STUN server connectivity over HTTPS', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer._options.config.iceServers[0].urls).toBe('stun:stun.l.google.com:19302');
                
                // STUN servers work over both HTTP and HTTPS, but test the configuration
                const stunUrl = window.peer._options.config.iceServers[0].urls;
                expect(stunUrl.startsWith('stun:')).toBe(true);
                expect(stunUrl.includes('google.com')).toBe(true);
            }, 2000);
            
            asyncTest('should validate PeerJS cloud server connectivity', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer.open).toBe(true);
                
                // If we have a peer ID, PeerJS cloud server connection is working
                expect(window.myId).not.toBeNull();
                expect(window.myId.length).toBe(16);
            }, 4000);
            
            asyncTest('should confirm external resources use HTTPS', () => {
                const scripts = document.querySelectorAll('script[src]');
                let httpsCount = 0;
                let httpCount = 0;
                
                scripts.forEach(script => {
                    if (script.src.startsWith('https://')) {
                        httpsCount++;
                    } else if (script.src.startsWith('http://')) {
                        httpCount++;
                    }
                });
                
                expect(httpsCount).toBe(1); // PeerJS library
                expect(httpCount).toBe(0); // No HTTP resources
            }, 1000);
            
            asyncTest('should handle HTTPS-specific WebRTC requirements', () => {
                if (window.location.protocol === 'https:') {
                    // In HTTPS context, all WebRTC APIs should be available
                    expect(typeof RTCPeerConnection).toBe('function');
                    expect(typeof RTCDataChannel).toBe('function');
                    expect(window.isSecureContext).toBe(true);
                } else {
                    // In HTTP context, APIs may be limited but should still exist for testing
                    expect(typeof RTCPeerConnection).toBe('function');
                    // Note: Some browsers may limit functionality in non-secure contexts
                }
            }, 1000);
        });
        
        // ===== MESSAGE HANDLING TESTS (FAILING) =====
        
        describe('Send Button Click Handler Tests', () => {
            test('should have handleSendClick function defined', () => {
                expect(typeof handleSendClick).toBe('function');
            });
            
            test('should not send empty messages', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = '';
                const result = handleSendClick();
                expect(result).toBe(false);
            });
            
            test('should not send messages when not connected', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                window.connection = null;
                const result = handleSendClick();
                expect(result).toBe(false);
            });
            
            test('should send message when connected with valid input', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                // Mock connection for testing
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const result = handleSendClick();
                expect(result).toBe(true);
                expect(mockConnection.lastSentData).toBe('test message');
            });
            
            test('should clear message input after sending', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {}
                };
                window.connection = mockConnection;
                
                handleSendClick();
                expect(messageInput.value).toBe('');
            });
        });
        
        describe('Message Sending Tests', () => {
            test('should have sendMessage function defined', () => {
                expect(typeof sendMessage).toBe('function');
            });
            
            test('should send message through connection', () => {
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                
                sendMessage('Hello World', mockConnection);
                expect(mockConnection.lastSentData).toBe('Hello World');
            });
            
            test('should add sent message to chat log with "Me:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockConnection = {
                    open: true,
                    send: function(data) {}
                };
                
                sendMessage('Hello World', mockConnection);
                expect(chatLog.value).toContain('Me: Hello World');
                expect(chatLog.value.length).toBe(initialLength + 'Me: Hello World\n'.length);
            });
        });
        
        describe('Message Receiving Tests', () => {
            test('should have handleReceivedMessage function defined', () => {
                expect(typeof handleReceivedMessage).toBe('function');
            });
            
            test('should add received message to chat log with "Peer:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                handleReceivedMessage('Hello from peer');
                expect(chatLog.value).toContain('Peer: Hello from peer');
                expect(chatLog.value.length).toBe(initialLength + 'Peer: Hello from peer\n'.length);
            });
        });
        
        describe('Message Formatting Tests', () => {
            test('should have addMessageToChat function defined', () => {
                expect(typeof addMessageToChat).toBe('function');
            });
            
            test('should format message with "Me:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'me');
                expect(chatLog.value).toContain('Me: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'Me: Test message\n'.length);
            });
            
            test('should format message with "Peer:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'peer');
                expect(chatLog.value).toContain('Peer: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'Peer: Test message\n'.length);
            });
            
            test('should format message with "System:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'system');
                expect(chatLog.value).toContain('System: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'System: Test message\n'.length);
            });
        });
        
        describe('Chat Log Update Tests', () => {
            test('should scroll chat log to bottom after adding message', () => {
                const chatLog = document.getElementById('chat-log');
                
                // Add multiple messages to create scrollable content
                for (let i = 0; i < 20; i++) {
                    addMessageToChat(`Message ${i}`, 'me');
                }
                
                // Check that scroll position is at bottom
                expect(chatLog.scrollTop).toBe(chatLog.scrollHeight - chatLog.clientHeight);
            });
            
            test('should maintain message history in chat log', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = ''; // Clear for this test
                
                addMessageToChat('First message', 'me');
                addMessageToChat('Second message', 'peer');
                addMessageToChat('Third message', 'system');
                
                expect(chatLog.value).toContain('Me: First message');
                expect(chatLog.value).toContain('Peer: Second message');
                expect(chatLog.value).toContain('System: Third message');
                
                // Check order is maintained
                const lines = chatLog.value.split('\n').filter(line => line.trim());
                expect(lines[0]).toBe('Me: First message');
                expect(lines[1]).toBe('Peer: Second message');
                expect(lines[2]).toBe('System: Third message');
            });
        });
        
        describe('Enter Key Message Sending Tests', () => {
            test('should have handleMessageInputKeyPress function defined', () => {
                expect(typeof handleMessageInputKeyPress).toBe('function');
            });
            
            test('should send message on Enter key press', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const mockEvent = {
                    key: 'Enter',
                    preventDefault: function() {}
                };
                
                handleMessageInputKeyPress(mockEvent);
                expect(mockConnection.lastSentData).toBe('test message');
                expect(messageInput.value).toBe('');
            });
            
            test('should not send message on other key presses', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const mockEvent = {
                    key: 'a',
                    preventDefault: function() {}
                };
                
                handleMessageInputKeyPress(mockEvent);
                expect(mockConnection.lastSentData).toBe(undefined);
                expect(messageInput.value).toBe('test message');
            });
        });
        
        // ===== CONNECTION ESTABLISHMENT TESTS (FAILING) =====
        
        describe('Connection Button Click Handler Tests', () => {
            test('should have handleConnectClick function defined', () => {
                expect(typeof handleConnectClick).toBe('function');
            });
            
            test('should prevent connection with empty peer ID', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = '';
                const result = handleConnectClick();
                expect(result).toBe(false);
            });
            
            test('should prevent self-connection', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                // Set a mock peer ID for testing
                window.myId = 'test-peer-id';
                peerIdInput.value = 'test-peer-id';
                const result = handleConnectClick();
                expect(result).toBe(false);
            });
            
            test('should initiate connection with valid peer ID', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'my-test-id';
                peerIdInput.value = 'other-peer-id';
                const result = handleConnectClick();
                expect(result).toBe(true);
            });
        });
        
        describe('Outgoing Connection Establishment Tests', () => {
            test('should have initiateConnection function defined', () => {
                expect(typeof initiateConnection).toBe('function');
            });
            
            test('should create connection when peer is available', () => {
                // Mock peer object for testing
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                const conn = initiateConnection('test-peer-id');
                expect(conn).not.toBeNull();
                expect(conn.peer).toBe('test-peer-id');
            });
            
            test('should store connection globally', () => {
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                initiateConnection('test-peer-id');
                expect(window.connection).not.toBeNull();
            });
        });
        
        describe('Incoming Connection Handling Tests', () => {
            test('should have handleIncomingConnection function defined', () => {
                expect(typeof handleIncomingConnection).toBe('function');
            });
            
            test('should accept incoming connection', () => {
                const mockConnection = { peer: 'incoming-peer-id', open: false };
                handleIncomingConnection(mockConnection);
                expect(window.connection).toBe(mockConnection);
            });
            
            test('should setup connection event handlers for incoming connection', () => {
                const mockConnection = { 
                    peer: 'incoming-peer-id', 
                    open: false,
                    on: function(event, handler) {
                        this['_' + event] = handler;
                    }
                };
                handleIncomingConnection(mockConnection);
                expect(typeof mockConnection._open).toBe('function');
                expect(typeof mockConnection._data).toBe('function');
                expect(typeof mockConnection._close).toBe('function');
            });
        });
        
        describe('Connection Open Event Tests', () => {
            test('should have handleConnectionOpen function defined', () => {
                expect(typeof handleConnectionOpen).toBe('function');
            });
            
            test('should add connection established message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                handleConnectionOpen();
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(chatLog.value.length).toBe(initialLength + 'System: ⚡ Connection established\n'.length);
            });
            
            test('should enable send button when connection opens', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = true; // Ensure it starts disabled
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
            });
        });
        
        describe('Send Button State Management Tests', () => {
            test('should have enableSendButton function defined', () => {
                expect(typeof enableSendButton).toBe('function');
            });
            
            test('should have disableSendButton function defined', () => {
                expect(typeof disableSendButton).toBe('function');
            });
            
            test('enableSendButton should enable the send button', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = true;
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
            });
            
            test('disableSendButton should disable the send button', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== INPUT VALIDATION AND ERROR HANDLING TESTS (FAILING) =====
        
        describe('Empty Peer ID Validation Tests', () => {
            test('should have validatePeerIdInput function defined', () => {
                expect(typeof validatePeerIdInput).toBe('function');
            });
            
            test('should return false for empty peer ID', () => {
                const result = validatePeerIdInput('');
                expect(result).toBe(false);
            });
            
            test('should return false for whitespace-only peer ID', () => {
                const result = validatePeerIdInput('   ');
                expect(result).toBe(false);
            });
            
            test('should return true for valid peer ID', () => {
                const result = validatePeerIdInput('valid-peer-id');
                expect(result).toBe(true);
            });
            
            test('should show error message for empty peer ID in connect handler', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                peerIdInput.value = '';
                handleConnectClick();
                
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                expect(chatLog.value.length).toBe(initialLength + 'System: Please enter a peer ID to connect\n'.length);
            });
        });
        
        describe('Self-Connection Prevention Tests', () => {
            test('should have validateSelfConnection function defined', () => {
                expect(typeof validateSelfConnection).toBe('function');
            });
            
            test('should return false when trying to connect to self', () => {
                window.myId = 'test-peer-id';
                const result = validateSelfConnection('test-peer-id');
                expect(result).toBe(false);
            });
            
            test('should return true when connecting to different peer', () => {
                window.myId = 'my-peer-id';
                const result = validateSelfConnection('other-peer-id');
                expect(result).toBe(true);
            });
            
            test('should show error message for self-connection attempt', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                window.myId = 'test-peer-id';
                peerIdInput.value = 'test-peer-id';
                handleConnectClick();
                
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                expect(chatLog.value.length).toBe(initialLength + 'System: Cannot connect to yourself\n'.length);
            });
        });
        
        describe('Connection Failure Error Handling Tests', () => {
            test('should have handleConnectionError function defined', () => {
                expect(typeof handleConnectionError).toBe('function');
            });
            
            test('should display user-friendly error message for connection failures', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'peer-unavailable', message: 'Could not connect to peer' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Peer not found or unavailable');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Peer not found or unavailable\n'.length);
            });
            
            test('should handle network error with appropriate message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'network', message: 'Network error occurred' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Network error - please check your internet connection');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Network error - please check your internet connection\n'.length);
            });
            
            test('should handle generic connection error with fallback message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { message: 'Unknown error' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Unknown error');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Unknown error\n'.length);
            });
        });
        
        describe('PeerJS Error Handling Tests', () => {
            test('should have handlePeerError function defined', () => {
                expect(typeof handlePeerError).toBe('function');
            });
            
            test('should handle peer-unavailable error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'peer-unavailable', message: 'Could not connect to peer' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Peer not found - please check the peer ID and try again');
                expect(chatLog.value.length).toBe(initialLength + 'System: Peer not found - please check the peer ID and try again\n'.length);
            });
            
            test('should handle network error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'network', message: 'Network connection failed' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Network error - please check your internet connection and try again');
                expect(chatLog.value.length).toBe(initialLength + 'System: Network error - please check your internet connection and try again\n'.length);
            });
            
            test('should handle server-error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'server-error', message: 'PeerJS server error' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Server error - please try again later');
                expect(chatLog.value.length).toBe(initialLength + 'System: Server error - please try again later\n'.length);
            });
            
            test('should handle generic PeerJS error with fallback message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { message: 'Generic PeerJS error' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: An error occurred: Generic PeerJS error');
                expect(chatLog.value.length).toBe(initialLength + 'System: An error occurred: Generic PeerJS error\n'.length);
            });
        });
        
        // ===== CODE ORGANIZATION AND DOCUMENTATION TESTS =====
        
        describe('Code Organization Tests', () => {
            test('should have all required function sections defined', () => {
                // Test that all major function categories exist
                expect(typeof addSystemMessage).toBe('function');
                expect(typeof updateMyId).toBe('function');
                expect(typeof validatePeerIdInput).toBe('function');
                expect(typeof validateSelfConnection).toBe('function');
                expect(typeof handleConnectionError).toBe('function');
                expect(typeof handlePeerError).toBe('function');
                expect(typeof handleConnectClick).toBe('function');
                expect(typeof initiateConnection).toBe('function');
                expect(typeof handleIncomingConnection).toBe('function');
                expect(typeof setupConnectionHandlers).toBe('function');
                expect(typeof handleConnectionOpen).toBe('function');
                expect(typeof enableSendButton).toBe('function');
                expect(typeof disableSendButton).toBe('function');
                expect(typeof handleConnectionClose).toBe('function');
                expect(typeof cleanupConnection).toBe('function');
                expect(typeof handleSendClick).toBe('function');
                expect(typeof sendMessage).toBe('function');
                expect(typeof handleReceivedMessage).toBe('function');
                expect(typeof addMessageToChat).toBe('function');
                expect(typeof handleMessageInputKeyPress).toBe('function');
                expect(typeof initializePeer).toBe('function');
                expect(typeof setupEventListeners).toBe('function');
            });
            
            test('should have proper function documentation', () => {
                // Test that functions have proper JSDoc-style comments
                const scriptContent = document.querySelector('script:last-of-type').textContent;
                
                // Check for function documentation patterns
                expect(scriptContent).toContain('/**');
                expect(scriptContent).toContain(' * ');
                expect(scriptContent).toContain(' */');
            });
            
            test('should have clear section organization with comments', () => {
                const scriptContent = document.querySelector('script:last-of-type').textContent;
                
                // Check for section headers
                expect(scriptContent).toContain('// ===== TESTING FRAMEWORK SETUP =====');
                expect(scriptContent).toContain('// ===== APPLICATION VARIABLES =====');
                expect(scriptContent).toContain('// ===== HELPER FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== INPUT VALIDATION FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== ERROR HANDLING FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== CONNECTION ESTABLISHMENT FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== CONNECTION CLOSURE FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== MESSAGE HANDLING FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== PEERJS INITIALIZATION =====');
                expect(scriptContent).toContain('// ===== EVENT LISTENERS SETUP =====');
                expect(scriptContent).toContain('// ===== APPLICATION INITIALIZATION =====');
            });
        });
        
        // ===== NETWORK ERROR HANDLING TESTS =====
        
        describe('Connection Status Management Tests', () => {
            test('should have updateConnectionStatus function defined', () => {
                expect(typeof updateConnectionStatus).toBe('function');
            });
            
            test('should update connection status indicator and text', () => {
                const indicator = document.getElementById('status-indicator');
                const statusText = document.getElementById('status-text');
                
                updateConnectionStatus('connected', 'Test Connected');
                expect(indicator.classList.contains('status-connected')).toBe(true);
                expect(statusText.textContent).toBe('Test Connected');
            });
            
            test('should show retry button on error status', () => {
                const retryBtn = document.getElementById('retry-btn');
                retryCount = 0; // Reset for test
                
                updateConnectionStatus('error', 'Test Error');
                expect(retryBtn.style.display).toBe('inline-block');
            });
            
            test('should hide retry button when max retries reached', () => {
                const retryBtn = document.getElementById('retry-btn');
                retryCount = maxRetries; // Set to max
                
                updateConnectionStatus('error', 'Test Error');
                expect(retryBtn.style.display).toBe('none');
            });
        });
        
        describe('Connection Progress Tests', () => {
            test('should have showConnectionProgress function defined', () => {
                expect(typeof showConnectionProgress).toBe('function');
            });
            
            test('should show progress bar with correct percentage', () => {
                const progressContainer = document.getElementById('connection-progress');
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                
                showConnectionProgress(75, 'Test Progress');
                
                expect(progressContainer.style.display).toBe('block');
                expect(progressFill.style.width).toBe('75%');
                expect(progressText.textContent).toBe('Test Progress');
            });
            
            test('should hide progress bar', () => {
                const progressContainer = document.getElementById('connection-progress');
                
                hideConnectionProgress();
                expect(progressContainer.style.display).toBe('none');
            });
        });
        
        describe('Network Diagnostics Tests', () => {
            test('should have runNetworkDiagnostics function defined', () => {
                expect(typeof runNetworkDiagnostics).toBe('function');
            });
            
            test('should return array of diagnostic results', () => {
                const diagnostics = runNetworkDiagnostics();
                expect(Array.isArray(diagnostics)).toBe(true);
                expect(diagnostics.length).toBe(5); // Expected number of checks
            });
            
            test('should show network diagnostics', () => {
                const diagnosticsContainer = document.getElementById('network-diagnostics');
                const testDiagnostics = [
                    { type: 'success', message: 'Test success' },
                    { type: 'error', message: 'Test error' }
                ];
                
                showNetworkDiagnostics(testDiagnostics);
                expect(diagnosticsContainer.style.display).toBe('block');
            });
            
            test('should hide network diagnostics', () => {
                const diagnosticsContainer = document.getElementById('network-diagnostics');
                
                hideNetworkDiagnostics();
                expect(diagnosticsContainer.style.display).toBe('none');
            });
        });
        
        describe('Enhanced Connection Error Handling Tests', () => {
            test('should handle NAT traversal failure errors', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const natError = { type: 'ice-connection-failed', message: 'ICE connection failed' };
                handleConnectionError(natError);
                
                expect(chatLog.value).toContain('NAT traversal failed');
                expect(chatLog.value).toContain('restrictive NATs/firewalls');
            });
            
            test('should handle network connectivity errors', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const networkError = { type: 'network', message: 'Network error' };
                handleConnectionError(networkError);
                
                expect(chatLog.value).toContain('Network connectivity issue');
                expect(chatLog.value).toContain('Firewall may be blocking');
            });
            
            test('should handle server errors', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const serverError = { type: 'server-error', message: 'Server error' };
                handleConnectionError(serverError);
                
                expect(chatLog.value).toContain('Signaling server error');
                expect(chatLog.value).toContain('usually temporary');
            });
            
            test('should provide troubleshooting tips', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const error = { type: 'peer-unavailable', message: 'Peer not found' };
                handleConnectionError(error);
                
                expect(chatLog.value).toContain('Troubleshooting Tips:');
                expect(chatLog.value).toContain('Double-check the peer ID');
            });
        });
        
        describe('Retry Logic Tests', () => {
            test('should have handleRetryClick function defined', () => {
                expect(typeof handleRetryClick).toBe('function');
            });
            
            test('should have retryConnection function defined', () => {
                expect(typeof retryConnection).toBe('function');
            });
            
            test('should increment retry count on retry', () => {
                retryCount = 0; // Reset
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = 'test-peer-id';
                
                // Mock the timeout to avoid waiting
                const originalSetTimeout = setTimeout;
                window.setTimeout = (fn, delay) => fn();
                
                retryConnection('test-peer-id');
                expect(retryCount).toBe(1);
                
                // Restore original setTimeout
                window.setTimeout = originalSetTimeout;
            });
            
            test('should not retry when max retries reached', () => {
                retryCount = maxRetries; // Set to max
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = 'test-peer-id';
                
                const initialRetryCount = retryCount;
                handleRetryClick();
                expect(retryCount).toBe(initialRetryCount); // Should not increment
            });
        });
        
        describe('Connection Timeout Tests', () => {
            test('should have handleConnectionTimeout function defined', () => {
                expect(typeof handleConnectionTimeout).toBe('function');
            });
            
            test('should handle connection timeout with appropriate message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                connectionStartTime = Date.now() - 5000; // 5 seconds ago
                handleConnectionTimeout('test-peer-id');
                
                expect(chatLog.value).toContain('Connection timeout');
                expect(chatLog.value).toContain('5 seconds');
            });
            
            test('should offer retry when attempts remaining', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                retryCount = 1; // Less than max
                handleConnectionTimeout('test-peer-id');
                
                expect(chatLog.value).toContain('retry attempts remaining');
            });
        });
        
        describe('ICE Connection State Handling Tests', () => {
            test('should have handleICEConnectionStateChange function defined', () => {
                expect(typeof handleICEConnectionStateChange).toBe('function');
            });
            
            test('should handle ICE connection failure', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                handleICEConnectionStateChange('failed');
                expect(chatLog.value).toContain('ICE connection failed');
            });
            
            test('should handle ICE disconnection', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                handleICEConnectionStateChange('disconnected');
                expect(chatLog.value).toContain('Network connection lost');
            });
        });
        
        describe('Connection Quality Information Tests', () => {
            test('should have showConnectionQualityInfo function defined', () => {
                expect(typeof showConnectionQualityInfo).toBe('function');
            });
            
            test('should handle missing connection gracefully', () => {
                window.connection = null;
                // Should not throw error
                expect(() => showConnectionQualityInfo()).not.toThrow();
            });
        });
        
        describe('Network Connectivity Monitoring Tests', () => {
            test('should handle online event', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                // Simulate online event
                const onlineEvent = new Event('online');
                window.dispatchEvent(onlineEvent);
                
                expect(chatLog.value).toContain('Network connectivity restored');
            });
            
            test('should handle offline event', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                // Simulate offline event
                const offlineEvent = new Event('offline');
                window.dispatchEvent(offlineEvent);
                
                expect(chatLog.value).toContain('Network connectivity lost');
            });
        });
        
        describe('Performance Monitoring Tests', () => {
            test('should have performance monitoring functions defined', () => {
                expect(typeof recordPageLoadTime).toBe('function');
                expect(typeof recordConnectionStart).toBe('function');
                expect(typeof recordConnectionEnd).toBe('function');
                expect(typeof startMemoryMonitoring).toBe('function');
                expect(typeof stopMemoryMonitoring).toBe('function');
                expect(typeof showPerformanceMetrics).toBe('function');
                expect(typeof updateConnectionQuality).toBe('function');
                expect(typeof logPerformanceMetrics).toBe('function');
            });
            
            test('should initialize performance metrics object', () => {
                expect(typeof performanceMetrics).toBe('object');
                expect(typeof performanceMetrics.pageLoadStart).toBe('number');
                expect(performanceMetrics.resourceLoadTimes instanceof Map).toBe(true);
                expect(typeof performanceMetrics.connectionQuality).toBe('object');
            });
            
            test('should record page load time', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                recordPageLoadTime();
                
                expect(performanceMetrics.pageLoadEnd).not.toBeNull();
                expect(chatLog.value).toContain('Page loaded in');
                expect(chatLog.value).toContain('ms');
            });
            
            test('should record connection timing', () => {
                recordConnectionStart();
                expect(performanceMetrics.connectionStartTime).not.toBeNull();
                
                // Simulate small delay
                setTimeout(() => {
                    const chatLog = document.getElementById('chat-log');
                    const initialLength = chatLog.value.length;
                    
                    recordConnectionEnd();
                    
                    expect(performanceMetrics.connectionEndTime).not.toBeNull();
                    expect(chatLog.value).toContain('Connection established in');
                }, 10);
            });
            
            test('should show performance metrics in UI', () => {
                const metricsContainer = document.getElementById('performance-metrics');
                const metricsInfo = document.getElementById('performance-info');
                
                expect(metricsContainer).not.toBeNull();
                expect(metricsInfo).not.toBeNull();
                
                showPerformanceMetrics();
                
                expect(metricsContainer.style.display).toBe('block');
                expect(metricsInfo.innerHTML).toContain('Page Load Time');
            });
            
            test('should classify performance metrics correctly', () => {
                expect(getLoadTimeClass(500)).toBe('metric-good');
                expect(getLoadTimeClass(2000)).toBe('metric-warning');
                expect(getLoadTimeClass(4000)).toBe('metric-poor');
                
                expect(getConnectionTimeClass(1000)).toBe('metric-good');
                expect(getConnectionTimeClass(3000)).toBe('metric-warning');
                expect(getConnectionTimeClass(6000)).toBe('metric-poor');
            });
            
            test('should handle memory monitoring gracefully', () => {
                // Should not throw error even if performance.memory is not available
                expect(() => startMemoryMonitoring()).not.toThrow();
                expect(() => stopMemoryMonitoring()).not.toThrow();
            });
            
            test('should log performance metrics', () => {
                const originalConsoleLog = console.log;
                let loggedData = null;
                
                console.log = (message, data) => {
                    if (message === 'Performance Metrics:') {
                        loggedData = data;
                    }
                };
                
                logPerformanceMetrics();
                
                expect(loggedData).not.toBeNull();
                expect(typeof loggedData.timestamp).toBe('string');
                expect(typeof loggedData.pageLoadTime).toBe('number');
                expect(typeof loggedData.userAgent).toBe('string');
                
                console.log = originalConsoleLog;
            });
        });
        
        describe('Connection Quality Monitoring Tests', () => {
            test('should have connection quality functions defined', () => {
                expect(typeof updateConnectionQuality).toBe('function');
                expect(typeof showConnectionQuality).toBe('function');
                expect(typeof startPerformanceMonitoring).toBe('function');
                expect(typeof stopPerformanceMonitoring).toBe('function');
            });
            
            test('should show connection quality in UI', () => {
                const qualityContainer = document.getElementById('connection-quality');
                const qualityInfo = document.getElementById('quality-info');
                
                expect(qualityContainer).not.toBeNull();
                expect(qualityInfo).not.toBeNull();
                
                const mockQualityData = {
                    rtt: 50,
                    bandwidth: 1500,
                    packetLoss: 0,
                    jitter: 10
                };
                
                showConnectionQuality(mockQualityData);
                
                expect(qualityContainer.style.display).toBe('block');
                expect(qualityInfo.innerHTML).toContain('Overall Quality');
                expect(qualityInfo.innerHTML).toContain('Round-trip Time');
            });
            
            test('should classify connection quality correctly', () => {
                expect(getRTTClass(50)).toBe('metric-good');
                expect(getRTTClass(200)).toBe('metric-warning');
                expect(getRTTClass(400)).toBe('metric-poor');
                
                expect(getBandwidthClass(2000)).toBe('metric-good');
                expect(getBandwidthClass(750)).toBe('metric-warning');
                expect(getBandwidthClass(300)).toBe('metric-poor');
                
                expect(getPacketLossClass(0)).toBe('metric-good');
                expect(getPacketLossClass(3)).toBe('metric-warning');
                expect(getPacketLossClass(10)).toBe('metric-poor');
            });
            
            test('should handle missing connection gracefully', () => {
                window.connection = null;
                expect(() => updateConnectionQuality()).not.toThrow();
                expect(() => startPerformanceMonitoring()).not.toThrow();
                expect(() => stopPerformanceMonitoring()).not.toThrow();
            });
        });
        
        describe('Helper Function Isolation Tests', () => {
            test('should have pure helper functions that don\'t modify global state directly', () => {
                // Test validatePeerIdInput is pure
                const result1 = validatePeerIdInput('test-id');
                const result2 = validatePeerIdInput('test-id');
                expect(result1).toBe(result2);
                expect(result1).toBe(true);
                
                // Test validateSelfConnection is pure (given same inputs)
                window.myId = 'my-id';
                const selfResult1 = validateSelfConnection('other-id');
                const selfResult2 = validateSelfConnection('other-id');
                expect(selfResult1).toBe(selfResult2);
                expect(selfResult1).toBe(true);
            });
            
            test('should have modular message formatting functions', () => {
                // Test addMessageToChat is modular and reusable
                const chatLog = document.getElementById('chat-log');
                const initialValue = chatLog.value;
                
                addMessageToChat('Test message 1', 'me');
                expect(chatLog.value).toContain('Me: Test message 1');
                
                addMessageToChat('Test message 2', 'peer');
                expect(chatLog.value).toContain('Peer: Test message 2');
                
                addMessageToChat('Test message 3', 'system');
                expect(chatLog.value).toContain('System: Test message 3');
                
                // Reset for other tests
                chatLog.value = initialValue;
            });
            
            test('should have reusable UI state management functions', () => {
                const sendBtn = document.getElementById('send-btn');
                
                // Test enableSendButton is reusable
                sendBtn.disabled = true;
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
                
                // Test disableSendButton is reusable
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should have modular error handling functions', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                // Test handleConnectionError is modular
                const connectionError = { type: 'network', message: 'Network failed' };
                handleConnectionError(connectionError);
                expect(chatLog.value).toContain('Network error - please check your internet connection');
                
                // Test handlePeerError is modular
                const peerError = { type: 'peer-unavailable', message: 'Peer not found' };
                handlePeerError(peerError);
                expect(chatLog.value).toContain('Peer not found - please check the peer ID and try again');
            });
        });
        
        describe('Function Documentation Standards Tests', () => {
            test('should have documented function parameters and return values', () => {
                // This test verifies that key functions have proper documentation
                // by checking their behavior matches documented expectations
                
                // validatePeerIdInput should return boolean
                expect(typeof validatePeerIdInput('test')).toBe('boolean');
                
                // validateSelfConnection should return boolean
                expect(typeof validateSelfConnection('test')).toBe('boolean');
                
                // addMessageToChat should not return anything (void)
                expect(addMessageToChat('test', 'me')).toBe(undefined);
                
                // handleSendClick should return boolean
                expect(typeof handleSendClick()).toBe('boolean');
                
                // handleConnectClick should return boolean
                expect(typeof handleConnectClick()).toBe('boolean');
            });
            
            test('should have functions with clear single responsibilities', () => {
                // Test that functions have single, clear responsibilities
                
                // addSystemMessage should only add system messages
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                addSystemMessage('Test system message');
                expect(chatLog.value).toContain('System: Test system message');
                
                // updateMyId should only update the peer ID display
                const myIdElement = document.getElementById('my-id');
                updateMyId('test-update-id');
                expect(myIdElement.textContent).toBe('test-update-id');
                expect(window.myId).toBe('test-update-id');
                
                // cleanupConnection should only clean up connection state
                window.connection = { open: true };
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                cleanupConnection();
                expect(window.connection).toBeNull();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== CONNECTION CLOSURE TESTS =====
        
        describe('Connection Close Event Handler Tests', () => {
            test('should have handleConnectionClose function defined', () => {
                expect(typeof handleConnectionClose).toBe('function');
            });
            
            test('should add connection closed message to chat log', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                handleConnectionClose();
                expect(chatLog.value).toContain('System: Connection closed');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection closed\n'.length);
            });
            
            test('should disable send button when connection closes', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false; // Ensure it starts enabled
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should clear connection variable when connection closes', () => {
                window.connection = { open: true };
                handleConnectionClose();
                expect(window.connection).toBeNull();
            });
        });
        
        describe('Connection Cleanup Tests', () => {
            test('should have cleanupConnection function defined', () => {
                expect(typeof cleanupConnection).toBe('function');
            });
            
            test('should reset connection state for new connections', () => {
                // Set up a mock connection state
                window.connection = { open: true };
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                
                cleanupConnection();
                
                expect(window.connection).toBeNull();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should allow new connections after cleanup', () => {
                // Simulate connection cleanup
                cleanupConnection();
                
                // Should be able to create new connection
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'my-test-id';
                peerIdInput.value = 'new-peer-id';
                
                // Mock peer for testing
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                const result = handleConnectClick();
                expect(result).toBe(true);
                expect(window.connection).not.toBeNull();
            });
        });
        
        describe('Connection State Management Tests', () => {
            test('should properly handle connection close event in setupConnectionHandlers', () => {
                const mockConnection = {
                    on: function(event, handler) {
                        this['_' + event] = handler;
                    }
                };
                
                setupConnectionHandlers(mockConnection);
                
                // Verify close handler is set up
                expect(typeof mockConnection._close).toBe('function');
                
                // Test that close handler calls handleConnectionClose
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                mockConnection._close();
                
                expect(chatLog.value).toContain('System: Connection closed');
            });
            
            test('should handle multiple connection close events gracefully', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = ''; // Clear for this test
                
                // Call handleConnectionClose multiple times
                handleConnectionClose();
                handleConnectionClose();
                
                // Should only add one message per call
                const lines = chatLog.value.split('\n').filter(line => line.trim());
                const closeMessages = lines.filter(line => line.includes('Connection closed'));
                expect(closeMessages.length).toBe(2);
            });
        });
        
        // ===== COMPREHENSIVE INTEGRATION TESTS =====
        
        describe('Complete User Workflow Integration Tests', () => {
            test('should complete full peer ID generation → connection → messaging → closure workflow', () => {
                // Reset state for clean test
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Step 1: Peer ID generation (simulated)
                const testPeerId = 'test-peer-12345';
                updateMyId(testPeerId);
                expect(window.myId).toBe(testPeerId);
                expect(document.getElementById('my-id').textContent).toBe(testPeerId);
                
                // Step 2: System message for peer ready
                addSystemMessage('Your ID is ready; share it with your peer.');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
                
                // Step 3: Connection establishment (simulated)
                const mockConnection = {
                    open: true,
                    peer: 'remote-peer-123',
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                handleConnectionOpen();
                
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(document.getElementById('send-btn').disabled).toBe(false);
                
                // Step 4: Message exchange
                sendMessage('Hello from integration test', mockConnection);
                expect(chatLog.value).toContain('Me: Hello from integration test');
                expect(mockConnection.lastSent).toBe('Hello from integration test');
                
                handleReceivedMessage('Hello back from peer');
                expect(chatLog.value).toContain('Peer: Hello back from peer');
                
                // Step 5: Connection closure
                handleConnectionClose();
                expect(chatLog.value).toContain('System: Connection closed');
                expect(document.getElementById('send-btn').disabled).toBe(true);
                expect(window.connection).toBeNull();
            });
            
            test('should handle multiple connection attempts in sequence', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up peer ID
                window.myId = 'test-peer-seq';
                
                // First connection attempt
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = 'peer-1';
                
                const mockPeer1 = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer1;
                
                const result1 = handleConnectClick();
                expect(result1).toBe(true);
                expect(window.connection.peer).toBe('peer-1');
                
                // Simulate connection close
                handleConnectionClose();
                expect(window.connection).toBeNull();
                
                // Second connection attempt
                peerIdInput.value = 'peer-2';
                const result2 = handleConnectClick();
                expect(result2).toBe(true);
                expect(window.connection.peer).toBe('peer-2');
                
                // Verify chat log shows both connection attempts
                expect(chatLog.value).toContain('System: Connection closed');
            });
            
            test('should handle rapid message sending during active connection', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.sentMessages = this.sentMessages || []; this.sentMessages.push(data); },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Send multiple messages rapidly
                const messages = ['Message 1', 'Message 2', 'Message 3', 'Message 4', 'Message 5'];
                messages.forEach(msg => {
                    sendMessage(msg, mockConnection);
                });
                
                // Verify all messages were sent and logged
                expect(mockConnection.sentMessages.length).toBe(5);
                messages.forEach(msg => {
                    expect(chatLog.value).toContain(`Me: ${msg}`);
                    expect(mockConnection.sentMessages).toContain(msg);
                });
                
                // Verify message order is maintained
                const chatLines = chatLog.value.split('\n').filter(line => line.startsWith('Me:'));
                expect(chatLines.length).toBe(5);
                messages.forEach((msg, index) => {
                    expect(chatLines[index]).toBe(`Me: ${msg}`);
                });
            });
            
            test('should handle incoming and outgoing messages interleaved', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Interleave sent and received messages
                sendMessage('Outgoing 1', mockConnection);
                handleReceivedMessage('Incoming 1');
                sendMessage('Outgoing 2', mockConnection);
                handleReceivedMessage('Incoming 2');
                sendMessage('Outgoing 3', mockConnection);
                
                // Verify message order and formatting
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines[0]).toBe('Me: Outgoing 1');
                expect(chatLines[1]).toBe('Peer: Incoming 1');
                expect(chatLines[2]).toBe('Me: Outgoing 2');
                expect(chatLines[3]).toBe('Peer: Incoming 2');
                expect(chatLines[4]).toBe('Me: Outgoing 3');
            });
        });
        
        describe('Edge Cases and Error Scenarios Integration Tests', () => {
            test('should handle connection failure during message sending', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up connection that will fail
                const mockConnection = {
                    open: true,
                    send: function(data) { 
                        // Simulate connection failure during send
                        this.open = false;
                        throw new Error('Connection lost');
                    },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Attempt to send message
                try {
                    sendMessage('Test message', mockConnection);
                } catch (error) {
                    // Connection should handle the error gracefully
                    expect(error.message).toBe('Connection lost');
                }
                
                // Verify message was still logged locally before failure
                expect(chatLog.value).toContain('Me: Test message');
            });
            
            test('should handle peer ID input with special characters and whitespace', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'test-peer';
                
                // Test with whitespace only
                peerIdInput.value = '   ';
                expect(handleConnectClick()).toBe(false);
                
                // Test with special characters
                peerIdInput.value = 'peer@#$%^&*()';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('peer@#$%^&*()');
                
                // Test with leading/trailing whitespace
                peerIdInput.value = '  valid-peer-id  ';
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('valid-peer-id');
            });
            
            test('should handle very long messages', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Create a very long message (1000 characters)
                const longMessage = 'A'.repeat(1000);
                
                sendMessage(longMessage, mockConnection);
                
                expect(mockConnection.lastSent).toBe(longMessage);
                expect(chatLog.value).toContain(`Me: ${longMessage}`);
                expect(chatLog.value.length).toBe(`Me: ${longMessage}\n`.length);
            });
            
            test('should handle multiple error types in sequence', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test sequence of different error types
                const errors = [
                    { type: 'peer-unavailable', message: 'Peer not found' },
                    { type: 'network', message: 'Network failed' },
                    { type: 'server-error', message: 'Server down' },
                    { message: 'Generic error' }
                ];
                
                errors.forEach(error => {
                    handlePeerError(error);
                });
                
                // Verify all error messages appear in chat log
                expect(chatLog.value).toContain('System: Peer not found - please check the peer ID and try again');
                expect(chatLog.value).toContain('System: Network error - please check your internet connection and try again');
                expect(chatLog.value).toContain('System: Server error - please try again later');
                expect(chatLog.value).toContain('System: An error occurred: Generic error');
                
                // Verify error messages are in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines.length).toBe(4);
            });
            
            test('should handle connection close during active messaging', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                
                // Start messaging
                sendMessage('Message before close', mockConnection);
                expect(chatLog.value).toContain('Me: Message before close');
                
                // Simulate connection close
                mockConnection._close();
                
                // Verify connection close was handled
                expect(chatLog.value).toContain('System: Connection closed');
                expect(window.connection).toBeNull();
                expect(document.getElementById('send-btn').disabled).toBe(true);
                
                // Attempt to send message after close should fail
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'Message after close';
                expect(handleSendClick()).toBe(false);
            });
        });
        
        describe('UI State Consistency Integration Tests', () => {
            test('should maintain consistent button states throughout connection lifecycle', () => {
                const sendBtn = document.getElementById('send-btn');
                const connectBtn = document.getElementById('connect-btn');
                
                // Initial state
                expect(sendBtn.disabled).toBe(true);
                expect(connectBtn.disabled).toBe(false);
                
                // During connection establishment
                const mockConnection = {
                    open: false,
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                
                // Connection opens
                mockConnection.open = true;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                // Connection closes
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
                expect(window.connection).toBeNull();
                
                // Should be able to connect again
                expect(connectBtn.disabled).toBe(false);
            });
            
            test('should maintain chat log consistency during all operations', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Track all operations and their expected chat log entries
                const operations = [
                    () => addSystemMessage('Peer ready'),
                    () => addSystemMessage('⚡ Connection established'),
                    () => addMessageToChat('Hello', 'me'),
                    () => addMessageToChat('Hi there', 'peer'),
                    () => addSystemMessage('Connection closed')
                ];
                
                const expectedEntries = [
                    'System: Peer ready',
                    'System: ⚡ Connection established',
                    'Me: Hello',
                    'Peer: Hi there',
                    'System: Connection closed'
                ];
                
                // Execute operations
                operations.forEach(op => op());
                
                // Verify all entries are present and in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines.length).toBe(expectedEntries.length);
                
                expectedEntries.forEach((expected, index) => {
                    expect(chatLines[index]).toBe(expected);
                });
                
                // Verify chat log scrolls to bottom
                expect(chatLog.scrollTop).toBe(chatLog.scrollHeight - chatLog.clientHeight);
            });
            
            test('should handle UI updates during rapid state changes', () => {
                const chatLog = document.getElementById('chat-log');
                const sendBtn = document.getElementById('send-btn');
                chatLog.value = '';
                
                // Rapid state changes: connect → message → disconnect → connect
                const mockConnection1 = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                // First connection
                window.connection = mockConnection1;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                
                // Send message
                sendMessage('Quick message', mockConnection1);
                expect(chatLog.value).toContain('Me: Quick message');
                
                // Close connection
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
                expect(chatLog.value).toContain('System: Connection closed');
                
                // Second connection
                const mockConnection2 = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                window.connection = mockConnection2;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                // Verify chat log shows both connections
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                const connectionMessages = chatLines.filter(line => line.includes('Connection established'));
                expect(connectionMessages.length).toBe(2);
            });
            
            test('should maintain input field states during all operations', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const messageInput = document.getElementById('message-input');
                
                // Test peer ID input persistence
                peerIdInput.value = 'test-peer-123';
                expect(peerIdInput.value).toBe('test-peer-123');
                
                // Input should persist through connection attempts
                window.myId = 'my-peer';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                handleConnectClick();
                expect(peerIdInput.value).toBe('test-peer-123'); // Should not be cleared
                
                // Test message input clearing after send
                messageInput.value = 'Test message';
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                handleSendClick();
                expect(messageInput.value).toBe(''); // Should be cleared after send
            });
        });
        
        describe('Real User Interaction Simulation Tests', () => {
            test('should simulate complete user session with Enter key usage', () => {
                const chatLog = document.getElementById('chat-log');
                const messageInput = document.getElementById('message-input');
                chatLog.value = '';
                
                // Set up connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.sentMessages = this.sentMessages || []; this.sentMessages.push(data); },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Simulate user typing and pressing Enter
                const messages = ['Hello!', 'How are you?', 'Great to chat!'];
                
                messages.forEach(msg => {
                    messageInput.value = msg;
                    const enterEvent = {
                        key: 'Enter',
                        preventDefault: function() { this.defaultPrevented = true; }
                    };
                    
                    handleMessageInputKeyPress(enterEvent);
                    
                    expect(enterEvent.defaultPrevented).toBe(true);
                    expect(messageInput.value).toBe('');
                    expect(chatLog.value).toContain(`Me: ${msg}`);
                });
                
                expect(mockConnection.sentMessages.length).toBe(3);
                expect(mockConnection.sentMessages).toContain('Hello!');
                expect(mockConnection.sentMessages).toContain('How are you?');
                expect(mockConnection.sentMessages).toContain('Great to chat!');
            });
            
            test('should simulate user attempting invalid operations', () => {
                const chatLog = document.getElementById('chat-log');
                const peerIdInput = document.getElementById('peer-id-input');
                const messageInput = document.getElementById('message-input');
                chatLog.value = '';
                
                // Attempt to send message without connection
                messageInput.value = 'Message without connection';
                expect(handleSendClick()).toBe(false);
                expect(chatLog.value).toContain('System: Not connected to any peer');
                
                // Attempt to connect with empty peer ID
                peerIdInput.value = '';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                
                // Attempt self-connection
                window.myId = 'my-peer-id';
                peerIdInput.value = 'my-peer-id';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                // Verify all error messages are in chat log
                const errorMessages = chatLog.value.split('\n').filter(line => line.includes('System:'));
                expect(errorMessages.length).toBe(3);
            });
            
            test('should simulate user recovering from errors', () => {
                const chatLog = document.getElementById('chat-log');
                const peerIdInput = document.getElementById('peer-id-input');
                chatLog.value = '';
                
                // Start with error condition
                window.myId = 'my-peer';
                peerIdInput.value = 'my-peer';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                // User corrects the error
                peerIdInput.value = 'valid-peer-id';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('valid-peer-id');
                
                // Simulate successful connection
                handleConnectionOpen();
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(document.getElementById('send-btn').disabled).toBe(false);
            });
        });
        
        describe('System Message Verification Tests', () => {
            test('should display all required system messages in correct scenarios', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test peer ready message
                addSystemMessage('Your ID is ready; share it with your peer.');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
                
                // Test connection established message
                addSystemMessage('⚡ Connection established');
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                
                // Test connection closed message
                addSystemMessage('Connection closed');
                expect(chatLog.value).toContain('System: Connection closed');
                
                // Test error messages
                addSystemMessage('Please enter a peer ID to connect');
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                
                addSystemMessage('Cannot connect to yourself');
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                addSystemMessage('Not connected to any peer');
                expect(chatLog.value).toContain('System: Not connected to any peer');
                
                // Verify all messages have System: prefix
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                chatLines.forEach(line => {
                    expect(line.startsWith('System:')).toBe(true);
                });
            });
            
            test('should verify system messages appear at correct times in workflow', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Simulate complete workflow with system message verification
                
                // 1. Peer initialization
                updateMyId('test-peer-123');
                addSystemMessage('Your ID is ready; share it with your peer.');
                
                // 2. Connection establishment
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                handleConnectionOpen();
                
                // 3. Message exchange (no system messages)
                sendMessage('Hello', mockConnection);
                handleReceivedMessage('Hi back');
                
                // 4. Connection closure
                handleConnectionClose();
                
                // Verify system messages appear in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                const systemMessages = chatLines.filter(line => line.startsWith('System:'));
                
                expect(systemMessages.length).toBe(3);
                expect(systemMessages[0]).toBe('System: Your ID is ready; share it with your peer.');
                expect(systemMessages[1]).toBe('System: ⚡ Connection established');
                expect(systemMessages[2]).toBe('System: Connection closed');
                
                // Verify user messages are interspersed correctly
                expect(chatLines[2]).toBe('Me: Hello');
                expect(chatLines[3]).toBe('Peer: Hi back');
            });
        });
        
        describe('Test Coverage Verification Tests', () => {
            test('should verify all major functions are tested', () => {
                const requiredFunctions = [
                    'addSystemMessage', 'updateMyId', 'validatePeerIdInput', 'validateSelfConnection',
                    'handleConnectionError', 'handlePeerError', 'handleConnectClick', 'initiateConnection',
                    'handleIncomingConnection', 'setupConnectionHandlers', 'handleConnectionOpen',
                    'enableSendButton', 'disableSendButton', 'handleConnectionClose', 'cleanupConnection',
                    'handleSendClick', 'sendMessage', 'handleReceivedMessage', 'addMessageToChat',
                    'handleMessageInputKeyPress', 'initializePeer', 'setupEventListeners'
                ];
                
                requiredFunctions.forEach(funcName => {
                    expect(typeof window[funcName]).toBe('function');
                });
            });
            
            test('should verify all DOM elements are accessible', () => {
                const requiredElements = [
                    'my-id', 'peer-id-input', 'connect-btn', 'chat-log', 'message-input', 'send-btn'
                ];
                
                requiredElements.forEach(elementId => {
                    const element = document.getElementById(elementId);
                    expect(element).not.toBeNull();
                });
            });
            
            test('should verify all error handling paths are covered', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test all error types
                const errorTypes = [
                    { type: 'peer-unavailable', handler: handlePeerError },
                    { type: 'network', handler: handlePeerError },
                    { type: 'server-error', handler: handlePeerError },
                    { type: 'peer-unavailable', handler: handleConnectionError },
                    { type: 'network', handler: handleConnectionError }
                ];
                
                errorTypes.forEach(({ type, handler }) => {
                    const error = { type, message: `Test ${type} error` };
                    handler(error);
                });
                
                // Verify all error messages appear
                expect(chatLog.value).toContain('Peer not found');
                expect(chatLog.value).toContain('Network error');
                expect(chatLog.value).toContain('Server error');
                expect(chatLog.value).toContain('Connection failed: Peer not found');
                expect(chatLog.value).toContain('Connection failed: Network error');
            });
            
            test('should verify all UI state transitions are covered', () => {
                const sendBtn = document.getElementById('send-btn');
                
                // Test all button state transitions
                expect(sendBtn.disabled).toBe(true); // Initial state
                
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
                
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
                
                // Test through connection lifecycle
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== APPLICATION VARIABLES =====
        
        // Global variables for PeerJS and connection management using modern const/let
        let peer = null;
        let connection = null;
        let myId = null;
        
        // Modern configuration using object destructuring and default parameters
        const CONFIG = {
            STUN_SERVER: 'stun:stun.l.google.com:19302',
            CONNECTION_TIMEOUT: 30000,
            MAX_RETRIES: 3,
            BASE_RETRY_DELAY: 2000,
            PERFORMANCE_MONITORING: true
        };
        
        // Modern Map for better performance than objects
        const connectionStates = new Map([
            ['disconnected', { indicator: 'status-disconnected', text: 'Disconnected' }],
            ['connecting', { indicator: 'status-connecting', text: 'Connecting...' }],
            ['connected', { indicator: 'status-connected', text: 'Connected' }],
            ['error', { indicator: 'status-error', text: 'Connection Failed' }]
        ]);
        let connectionTimeout = null;
        let retryCount = 0;
        const MAX_RETRIES = 3;
        const BASE_RETRY_DELAY = 2000; // 2 seconds
        let connectionStartTime = null;
        
        // ===== PERFORMANCE MONITORING VARIABLES =====
        
        let performanceMetrics = {
            pageLoadStart: performance.now(),
            pageLoadEnd: null,
            connectionStartTime: null,
            connectionEndTime: null,
            memoryBaseline: null,
            resourceLoadTimes: new Map(),
            connectionQuality: {
                rtt: null,
                bandwidth: null,
                packetLoss: null,
                jitter: null
            }
        };
        
        let performanceMonitoringInterval = null;
        let memoryMonitoringInterval = null;
        
        // Make variables globally accessible for testing
        Object.assign(window, { peer, connection, myId });
        
        // ===== HELPER FUNCTIONS =====
        
        /**
         * Adds a system message to the chat log
         * @param {string} message - The system message to add
         */
        const addSystemMessage = (message) => {
            addMessageToChat(message, 'system');
        };
        
        /**
         * Updates the displayed peer ID and stores it globally
         * @param {string} id - The peer ID to display and store
         */
        const updateMyId = (id) => {
            const myIdElement = document.getElementById('my-id');
            myIdElement.textContent = id;
            myId = id;
            window.myId = id;
        };
        
        // ===== PERFORMANCE MONITORING FUNCTIONS =====
        
        /**
         * Records page load completion time and displays metrics
         */
        const recordPageLoadTime = () => {
            performanceMetrics.pageLoadEnd = performance.now();
            const loadTime = performanceMetrics.pageLoadEnd - performanceMetrics.pageLoadStart;
            
            addSystemMessage(`📊 Page loaded in ${Math.round(loadTime)}ms`);
            
            // Record resource load times
            if (performance.getEntriesByType) {
                const resources = performance.getEntriesByType('resource');
                resources.forEach(resource => {
                    if (resource.name.includes('peerjs') || resource.name.includes('jest')) {
                        const resourceLoadTime = resource.responseEnd - resource.requestStart;
                        performanceMetrics.resourceLoadTimes.set(resource.name, resourceLoadTime);
                    }
                });
            }
            
            showPerformanceMetrics();
        };
        
        /**
         * Records connection establishment start time
         */
        const recordConnectionStart = () => {
            performanceMetrics.connectionStartTime = performance.now();
            connectionStartTime = Date.now(); // Keep existing variable for compatibility
        };
        
        /**
         * Records connection establishment completion time
         */
        const recordConnectionEnd = () => {
            performanceMetrics.connectionEndTime = performance.now();
            const connectionTime = performanceMetrics.connectionEndTime - performanceMetrics.connectionStartTime;
            
            addSystemMessage(`⚡ Connection established in ${Math.round(connectionTime)}ms`);
            updatePerformanceMetrics();
        };
        
        /**
         * Starts memory usage monitoring
         */
        const startMemoryMonitoring = () => {
            if (!performance.memory) {
                addSystemMessage('💾 Memory monitoring not available in this browser');
                return;
            }
            
            performanceMetrics.memoryBaseline = performance.memory.usedJSHeapSize;
            
            memoryMonitoringInterval = setInterval(() => {
                const currentMemory = performance.memory.usedJSHeapSize;
                const memoryIncrease = currentMemory - performanceMetrics.memoryBaseline;
                
                // Alert if memory usage increases significantly (>10MB)
                if (memoryIncrease > 10 * 1024 * 1024) {
                    addSystemMessage(`⚠️ Memory usage increased by ${Math.round(memoryIncrease / 1024 / 1024)}MB`);
                    performanceMetrics.memoryBaseline = currentMemory; // Reset baseline
                }
            }, 30000); // Check every 30 seconds
        };
        
        /**
         * Stops memory usage monitoring
         */
        const stopMemoryMonitoring = () => {
            if (memoryMonitoringInterval) {
                clearInterval(memoryMonitoringInterval);
                memoryMonitoringInterval = null;
            }
        };
        
        /**
         * Shows performance metrics in the UI
         */
        const showPerformanceMetrics = () => {
            const metricsContainer = document.getElementById('performance-metrics');
            const metricsInfo = document.getElementById('performance-info');
            
            if (!metricsContainer || !metricsInfo) return;
            
            const loadTime = performanceMetrics.pageLoadEnd - performanceMetrics.pageLoadStart;
            const connectionTime = performanceMetrics.connectionEndTime && performanceMetrics.connectionStartTime 
                ? performanceMetrics.connectionEndTime - performanceMetrics.connectionStartTime 
                : null;
            
            let html = `
                <div class="metric-item">
                    <span>Page Load Time:</span>
                    <span class="metric-value ${getLoadTimeClass(loadTime)}">${Math.round(loadTime)}ms</span>
                </div>
            `;
            
            if (connectionTime) {
                html += `
                    <div class="metric-item">
                        <span>Connection Time:</span>
                        <span class="metric-value ${getConnectionTimeClass(connectionTime)}">${Math.round(connectionTime)}ms</span>
                    </div>
                `;
            }
            
            if (performance.memory) {
                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                html += `
                    <div class="metric-item">
                        <span>Memory Usage:</span>
                        <span class="metric-value ${getMemoryClass(memoryMB)}">${memoryMB}MB</span>
                    </div>
                `;
            }
            
            // Show resource load times
            for (const [resource, time] of performanceMetrics.resourceLoadTimes) {
                const resourceName = resource.includes('peerjs') ? 'PeerJS' : 'Jest';
                html += `
                    <div class="metric-item">
                        <span>${resourceName} Load:</span>
                        <span class="metric-value ${getResourceTimeClass(time)}">${Math.round(time)}ms</span>
                    </div>
                `;
            }
            
            metricsInfo.innerHTML = html;
            metricsContainer.style.display = 'block';
        };
        
        /**
         * Updates performance metrics display
         */
        const updatePerformanceMetrics = () => {
            showPerformanceMetrics();
            updateConnectionQuality();
        };
        
        /**
         * Gets CSS class for load time based on performance thresholds
         */
        const getLoadTimeClass = (time) => {
            if (time < 1000) return 'metric-good';
            if (time < 3000) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Gets CSS class for connection time based on performance thresholds
         */
        const getConnectionTimeClass = (time) => {
            if (time < 2000) return 'metric-good';
            if (time < 5000) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Gets CSS class for memory usage based on thresholds
         */
        const getMemoryClass = (memoryMB) => {
            if (memoryMB < 50) return 'metric-good';
            if (memoryMB < 100) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Gets CSS class for resource load time based on thresholds
         */
        const getResourceTimeClass = (time) => {
            if (time < 500) return 'metric-good';
            if (time < 1500) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Starts performance monitoring for connection quality
         */
        const startPerformanceMonitoring = () => {
            if (!connection?.peerConnection) return;
            
            performanceMonitoringInterval = setInterval(async () => {
                await updateConnectionQuality();
            }, 5000); // Update every 5 seconds
        };
        
        /**
         * Stops performance monitoring
         */
        const stopPerformanceMonitoring = () => {
            if (performanceMonitoringInterval) {
                clearInterval(performanceMonitoringInterval);
                performanceMonitoringInterval = null;
            }
        };
        
        /**
         * Updates connection quality indicators
         */
        const updateConnectionQuality = async () => {
            if (!connection?.peerConnection) return;
            
            try {
                const stats = await connection.peerConnection.getStats();
                let qualityData = {
                    rtt: null,
                    bandwidth: null,
                    packetLoss: null,
                    jitter: null
                };
                
                for (const report of stats.values()) {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        qualityData.rtt = report.currentRoundTripTime ? Math.round(report.currentRoundTripTime * 1000) : null;
                        qualityData.bandwidth = report.availableOutgoingBitrate ? Math.round(report.availableOutgoingBitrate / 1000) : null;
                    }
                    
                    if (report.type === 'inbound-rtp' && report.mediaType === 'audio') {
                        qualityData.packetLoss = report.packetsLost || 0;
                        qualityData.jitter = report.jitter ? Math.round(report.jitter * 1000) : null;
                    }
                }
                
                performanceMetrics.connectionQuality = qualityData;
                showConnectionQuality(qualityData);
                
            } catch (error) {
                console.warn('Could not get connection quality stats:', error);
            }
        };
        
        /**
         * Shows connection quality indicators in the UI
         */
        const showConnectionQuality = (qualityData) => {
            const qualityContainer = document.getElementById('connection-quality');
            const qualityInfo = document.getElementById('quality-info');
            
            if (!qualityContainer || !qualityInfo) return;
            
            let overallQuality = 'excellent';
            let html = '';
            
            if (qualityData.rtt !== null) {
                const rttClass = getRTTClass(qualityData.rtt);
                if (rttClass !== 'metric-good') overallQuality = rttClass === 'metric-warning' ? 'good' : 'poor';
                
                html += `
                    <div class="metric-item">
                        <span>Round-trip Time:</span>
                        <span class="metric-value ${rttClass}">${qualityData.rtt}ms</span>
                    </div>
                `;
            }
            
            if (qualityData.bandwidth !== null) {
                const bandwidthClass = getBandwidthClass(qualityData.bandwidth);
                if (bandwidthClass !== 'metric-good' && overallQuality === 'excellent') {
                    overallQuality = bandwidthClass === 'metric-warning' ? 'good' : 'poor';
                }
                
                html += `
                    <div class="metric-item">
                        <span>Bandwidth:</span>
                        <span class="metric-value ${bandwidthClass}">${qualityData.bandwidth} kbps</span>
                    </div>
                `;
            }
            
            if (qualityData.packetLoss !== null) {
                const lossClass = getPacketLossClass(qualityData.packetLoss);
                if (lossClass !== 'metric-good' && overallQuality !== 'poor') {
                    overallQuality = lossClass === 'metric-warning' ? 'good' : 'poor';
                }
                
                html += `
                    <div class="metric-item">
                        <span>Packet Loss:</span>
                        <span class="metric-value ${lossClass}">${qualityData.packetLoss}</span>
                    </div>
                `;
            }
            
            // Add overall quality indicator
            html = `
                <div class="metric-item">
                    <span><span class="quality-indicator quality-${overallQuality}"></span>Overall Quality:</span>
                    <span class="metric-value">${overallQuality.charAt(0).toUpperCase() + overallQuality.slice(1)}</span>
                </div>
            ` + html;
            
            qualityInfo.innerHTML = html;
            qualityContainer.style.display = 'block';
        };
        
        /**
         * Gets CSS class for RTT based on quality thresholds
         */
        const getRTTClass = (rtt) => {
            if (rtt < 100) return 'metric-good';
            if (rtt < 300) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Gets CSS class for bandwidth based on quality thresholds
         */
        const getBandwidthClass = (bandwidth) => {
            if (bandwidth > 1000) return 'metric-good';
            if (bandwidth > 500) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Gets CSS class for packet loss based on quality thresholds
         */
        const getPacketLossClass = (packetLoss) => {
            if (packetLoss === 0) return 'metric-good';
            if (packetLoss < 5) return 'metric-warning';
            return 'metric-poor';
        };
        
        /**
         * Hides performance metrics display
         */
        const hidePerformanceMetrics = () => {
            const metricsContainer = document.getElementById('performance-metrics');
            if (metricsContainer) {
                metricsContainer.style.display = 'none';
            }
        };
        
        /**
         * Hides connection quality display
         */
        const hideConnectionQuality = () => {
            const qualityContainer = document.getElementById('connection-quality');
            if (qualityContainer) {
                qualityContainer.style.display = 'none';
            }
        };
        
        /**
         * Logs performance metrics for deployment analysis
         */
        const logPerformanceMetrics = () => {
            const metrics = {
                timestamp: new Date().toISOString(),
                pageLoadTime: performanceMetrics.pageLoadEnd - performanceMetrics.pageLoadStart,
                connectionTime: performanceMetrics.connectionEndTime && performanceMetrics.connectionStartTime 
                    ? performanceMetrics.connectionEndTime - performanceMetrics.connectionStartTime 
                    : null,
                memoryUsage: performance.memory ? performance.memory.usedJSHeapSize : null,
                connectionQuality: performanceMetrics.connectionQuality,
                userAgent: navigator.userAgent,
                url: window.location.href
            };
            
            console.log('Performance Metrics:', metrics);
            
            // In a real deployment, this could send metrics to an analytics service
            // For now, we'll just store in sessionStorage for debugging
            try {
                const existingMetrics = JSON.parse(sessionStorage.getItem('performanceMetrics') || '[]');
                existingMetrics.push(metrics);
                
                // Keep only last 10 entries to avoid storage bloat
                if (existingMetrics.length > 10) {
                    existingMetrics.splice(0, existingMetrics.length - 10);
                }
                
                sessionStorage.setItem('performanceMetrics', JSON.stringify(existingMetrics));
            } catch (error) {
                console.warn('Could not store performance metrics:', error);
            }
        };
        
        // ===== CONNECTION STATUS MANAGEMENT =====
        
        /**
         * Updates the connection status indicator and text
         * @param {string} status - The status ('disconnected', 'connecting', 'connected', 'error')
         * @param {string} text - The status text to display
         */
        const updateConnectionStatus = (status, text) => {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            const retryBtn = document.getElementById('retry-btn');
            
            // Remove all status classes
            indicator.className = 'status-indicator';
            
            // Add appropriate status class
            indicator.classList.add(`status-${status}`);
            statusText.textContent = text;
            
            // Show/hide retry button
            retryBtn.style.display = (status === 'error' && retryCount < maxRetries) ? 'inline-block' : 'none';
        };
        
        /**
         * Shows connection progress with animated progress bar
         * @param {number} progress - Progress percentage (0-100)
         * @param {string} text - Progress text to display
         */
        const showConnectionProgress = (progress, text) => {
            const progressContainer = document.getElementById('connection-progress');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = `${progress}%`;
            progressText.textContent = text;
        };
        
        /**
         * Hides the connection progress indicator
         */
        const hideConnectionProgress = () => {
            document.getElementById('connection-progress').style.display = 'none';
        };
        
        /**
         * Shows network diagnostics information
         * @param {Array} diagnostics - Array of diagnostic items
         */
        const showNetworkDiagnostics = (diagnostics) => {
            const diagnosticsContainer = document.getElementById('network-diagnostics');
            const diagnosticInfo = document.getElementById('diagnostic-info');
            
            // Use modern DOM manipulation with template literals
            diagnosticInfo.innerHTML = diagnostics
                .map(({ type, message }) => 
                    `<div class="diagnostic-item diagnostic-${type}">${message}</div>`
                )
                .join('');
            
            diagnosticsContainer.style.display = 'block';
        };
        
        /**
         * Hides network diagnostics information
         */
        const hideNetworkDiagnostics = () => {
            document.getElementById('network-diagnostics').style.display = 'none';
        };
        
        /**
         * Runs network diagnostics and returns results
         * @returns {Array} Array of diagnostic results
         */
        const runNetworkDiagnostics = () => [
            // Check secure context
            {
                type: window.isSecureContext ? 'success' : 'warning',
                message: window.isSecureContext 
                    ? '✓ Secure context (HTTPS) - WebRTC fully supported'
                    : '⚠ Non-secure context - WebRTC may be limited'
            },
            // Modern browsers have native WebRTC support
            {
                type: 'success',
                message: '✓ WebRTC APIs available'
            },
            // Check PeerJS availability (modern browsers support external libraries)
            {
                type: 'success',
                message: '✓ PeerJS library loaded'
            },
            // Check peer initialization status
            ...(peer?.open 
                ? [{ type: 'success', message: '✓ Peer connection initialized' }]
                : peer 
                    ? [{ type: 'warning', message: '⚠ Peer initializing...' }]
                    : [{ type: 'error', message: '✗ Peer not initialized' }]
            ),
            // Check network connectivity
            {
                type: navigator.onLine ? 'success' : 'error',
                message: navigator.onLine 
                    ? '✓ Network connectivity detected'
                    : '✗ No network connectivity'
            }
        ];
        
        // ===== INPUT VALIDATION FUNCTIONS =====
        
        /**
         * Validates peer ID input for empty or whitespace-only values
         * @param {string} peerId - The peer ID to validate
         * @returns {boolean} True if valid, false if empty or whitespace-only
         */
        const validatePeerIdInput = (peerId) => Boolean(peerId?.trim());
        
        /**
         * Validates that the user is not trying to connect to themselves
         * @param {string} targetPeerId - The peer ID to connect to
         * @returns {boolean} True if different from own ID, false if same
         */
        const validateSelfConnection = (targetPeerId) => myId !== targetPeerId;
        
        // ===== ERROR HANDLING FUNCTIONS =====
        
        /**
         * Handles connection errors with user-friendly messages and network diagnostics
         * @param {Object} error - The error object containing type and message
         */
        const handleConnectionError = (error) => {
            // Clear any existing timeout
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            
            const errorConfig = new Map([
                ['peer-unavailable', {
                    message: '🔍 Connection failed: Peer not found or unavailable',
                    diagnostics: [
                        { type: 'error', message: 'Target peer ID may be incorrect or offline' },
                        { type: 'warning', message: 'Verify the peer ID is exactly as provided' },
                        { type: 'warning', message: 'Ensure the other user is online and ready' }
                    ]
                }],
                ['network', {
                    message: '🌐 Connection failed: Network connectivity issue',
                    diagnostics: [
                        { type: 'error', message: 'Network connection interrupted or blocked' },
                        { type: 'warning', message: 'Check your internet connection' },
                        { type: 'warning', message: 'Firewall may be blocking WebRTC traffic' },
                        { type: 'warning', message: 'Corporate networks often restrict P2P connections' }
                    ]
                }],
                ['ice-connection-failed', {
                    message: '🧊 Connection failed: NAT traversal failed',
                    diagnostics: [
                        { type: 'error', message: 'Unable to establish direct peer connection' },
                        { type: 'warning', message: 'Both peers may be behind restrictive NATs/firewalls' },
                        { type: 'warning', message: 'STUN server may be unreachable' },
                        { type: 'warning', message: 'Try connecting from different networks' }
                    ]
                }],
                ['ice-connection-disconnected', {
                    message: '❄️ Connection lost: Network path changed',
                    diagnostics: [
                        { type: 'warning', message: 'Network route between peers changed' },
                        { type: 'warning', message: 'One peer may have switched networks' },
                        { type: 'warning', message: 'Connection will attempt to reconnect automatically' }
                    ]
                }],
                ['server-error', {
                    message: '🖥️ Connection failed: Signaling server error',
                    diagnostics: [
                        { type: 'error', message: 'PeerJS signaling server is unavailable' },
                        { type: 'warning', message: 'This is usually temporary' },
                        { type: 'warning', message: 'Try again in a few moments' }
                    ]
                }]
            ]);
            
            const config = errorConfig.get(error.type) ?? {
                message: `❌ Connection failed: ${error.message || 'Unknown error'}`,
                diagnostics: [
                    { type: 'error', message: 'An unexpected error occurred' },
                    { type: 'warning', message: 'Please try connecting again' }
                ]
            };
            
            updateConnectionStatus('error', 'Connection Failed');
            addSystemMessage(config.message);
            
            // Show troubleshooting tips using modern array methods
            const troubleshootingTips = [
                '• Double-check the peer ID for typos',
                '• Ensure both peers are online and ready',
                '• Try refreshing the page and reconnecting',
                '• Check your network connection'
            ];
            
            addSystemMessage('');
            addSystemMessage('🔧 Troubleshooting Tips:');
            troubleshootingTips.forEach(tip => addSystemMessage(tip));
            
            // Show network diagnostics
            showNetworkDiagnostics(config.diagnostics);
            
            // Clean up connection state
            cleanupConnection();
        };
        
        /**
         * Adds network-specific troubleshooting tips to the chat
         * @param {string} errorType - The type of error that occurred
         */
        const addNetworkTroubleshootingTips = (errorType) => {
            const tips = new Map([
                ['peer-unavailable', [
                    '• Double-check the peer ID for typos',
                    '• Ensure both users are using the same application',
                    '• Ask the other user to refresh their page'
                ]],
                ['network', [
                    '• Try connecting from a different network (mobile hotspot)',
                    '• Check if your firewall allows WebRTC traffic',
                    '• Corporate/school networks often block P2P connections',
                    '• Ensure both peers have stable internet connections'
                ]],
                ['ice-connection-failed', [
                    '• Try connecting from a different network (mobile hotspot)',
                    '• Check if your firewall allows WebRTC traffic',
                    '• Corporate/school networks often block P2P connections',
                    '• Ensure both peers have stable internet connections'
                ]],
                ['server-error', [
                    '• Wait a few minutes and try again',
                    '• Check if PeerJS service status is normal',
                    '• Try refreshing the page'
                ]]
            ]);
            
            const defaultTips = [
                '• Try refreshing the page and reconnecting',
                '• Check browser console for technical details',
                '• Ensure stable internet connection'
            ];
            
            addSystemMessage('');
            addSystemMessage('🔧 Troubleshooting Tips:');
            
            const errorTips = tips.get(errorType) ?? defaultTips;
            errorTips.forEach(tip => addSystemMessage(tip));
            
            if (!window.isSecureContext) {
                const httpsTips = [
                    '• Access via HTTPS for full WebRTC functionality',
                    '• GitHub Pages URL: https://mehrmorgen.github.io/CanChat/chat.html'
                ];
                httpsTips.forEach(tip => addSystemMessage(tip));
            }
        };
        
        /**
         * Handles PeerJS errors with user-friendly messages
         * @param {Object} error - The PeerJS error object
         */
        const handlePeerError = (error) => {
            const errorMessages = new Map([
                ['peer-unavailable', 'Peer not found - please check the peer ID and try again'],
                ['network', 'Network error - please check your internet connection and try again'],
                ['server-error', 'Server error - please try again later'],

                ['ssl-unavailable', 'SSL/HTTPS required for WebRTC - please access via HTTPS'],
                ['unavailable-id', 'Peer ID unavailable - please try again with a different ID'],
                ['disconnected', 'Disconnected from signaling server - please refresh and try again']
            ]);
            
            const errorMessage = errorMessages.get(error.type) ?? 
                `An error occurred: ${error.message || 'Unknown error'}`;
            addSystemMessage(errorMessage);
            
            // Modern conditional logic with destructuring
            const { type, message } = error;
            const isHttpContext = window.location.protocol === 'http:';
            const isSecureContext = window.isSecureContext;
            
            // HTTPS-specific guidance using modern patterns
            const httpsGuidance = {
                network: !isSecureContext && [
                    '💡 Network errors are more common in non-HTTPS environments.',
                    '💡 Try accessing via HTTPS for better connectivity.'
                ],
                'server-error': isHttpContext && [
                    '💡 Server errors may occur when using HTTP instead of HTTPS.',
                    '💡 PeerJS cloud servers work best with HTTPS connections.'
                ],
                'ssl-unavailable': [
                    '🔒 This error occurs when trying to use WebRTC over HTTP.',
                    '💡 Access this application via HTTPS for full functionality.'
                ]
            };
            
            const guidance = httpsGuidance[type];
            if (guidance) {
                guidance.forEach(msg => addSystemMessage(msg));
            }
            
            // Check for HTTPS-related error messages in unknown errors
            if (!errorMessages.has(type) && message?.includes('secure')) {
                const securityMessages = [
                    '🔒 This appears to be an HTTPS/security-related error.',
                    '💡 Ensure you are accessing the application via HTTPS.'
                ];
                securityMessages.forEach(msg => addSystemMessage(msg));
            }
        };
        
        // Expose variables globally for testing
        window.peer = peer;
        window.connection = connection;
        window.myId = myId;
        

        
        // ===== CONNECTION ESTABLISHMENT FUNCTIONS =====
        
        /**
         * Handles the connect button click event with validation and connection initiation
         * @returns {boolean} True if connection attempt was initiated, false if validation failed
         */
        const handleConnectClick = () => {
            const peerIdInput = document.getElementById('peer-id-input');
            const targetPeerId = peerIdInput.value.trim();
            
            // Validate peer ID input
            if (!validatePeerIdInput(targetPeerId)) {
                addSystemMessage('Please enter a peer ID to connect');
                return false;
            }
            
            // Prevent self-connection
            if (!validateSelfConnection(targetPeerId)) {
                addSystemMessage('Cannot connect to yourself');
                return false;
            }
            
            // Reset retry count for new connection attempt
            retryCount = 0;
            
            // Initiate connection with timeout and progress tracking
            initiateConnectionWithTimeout(targetPeerId);
            return true;
        }
        
        /**
         * Handles retry button click event
         */
        const handleRetryClick = () => {
            const peerIdInput = document.getElementById('peer-id-input');
            const targetPeerId = peerIdInput.value.trim();
            
            if (targetPeerId && retryCount < MAX_RETRIES) {
                retryConnection(targetPeerId);
            }
        };
        
        /**
         * Retries connection with exponential backoff
         * @param {string} peerId - The peer ID to retry connecting to
         */
        const retryConnection = (peerId) => {
            retryCount++;
            const delay = BASE_RETRY_DELAY * (2 ** (retryCount - 1)); // Modern exponentiation
            
            addSystemMessage(`🔄 Retrying connection (attempt ${retryCount}/${MAX_RETRIES})...`);
            addSystemMessage(`⏱️ Waiting ${delay/1000} seconds before retry...`);
            
            updateConnectionStatus('connecting', `Retrying in ${delay/1000}s...`);
            
            setTimeout(() => {
                if (retryCount <= MAX_RETRIES) {
                    initiateConnectionWithTimeout(peerId);
                }
            }, delay);
        };
        
        /**
         * Initiates connection with timeout handling and progress tracking
         * @param {string} peerId - The peer ID to connect to
         */
        const initiateConnectionWithTimeout = (peerId) => {
            // Clear any existing timeout
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
            }
            
            // Update UI to show connecting state
            updateConnectionStatus('connecting', 'Connecting...');
            showConnectionProgress(10, 'Initializing connection...');
            hideNetworkDiagnostics();
            
            // Record connection start time
            connectionStartTime = Date.now();
            
            // Set connection timeout (30 seconds)
            connectionTimeout = setTimeout(() => {
                handleConnectionTimeout(peerId);
            }, 30000);
            
            // Initiate the actual connection
            const conn = initiateConnection(peerId);
            
            if (conn) {
                // Update progress
                showConnectionProgress(30, 'Establishing peer connection...');
                
                // Monitor connection establishment
                monitorConnectionProgress(conn);
            }
        };
        
        /**
         * Monitors connection progress and updates UI accordingly
         * @param {Object} conn - The connection object to monitor
         */
        const monitorConnectionProgress = (conn) => {
            let progressValue = 30;
            
            // Simulate progress updates
            const progressInterval = setInterval(() => {
                if (conn.open) {
                    clearInterval(progressInterval);
                    showConnectionProgress(100, 'Connected!');
                    setTimeout(hideConnectionProgress, 2000);
                } else if (progressValue < 80) {
                    progressValue += 10;
                    showConnectionProgress(progressValue, 'Negotiating connection...');
                }
            }, 1000);
            
            // Clear interval if connection fails or times out
            setTimeout(() => {
                clearInterval(progressInterval);
            }, 30000);
        };
        
        /**
         * Handles connection timeout
         * @param {string} peerId - The peer ID that timed out
         */
        const handleConnectionTimeout = (peerId) => {
            const elapsedTime = Date.now() - connectionStartTime;
            
            addSystemMessage(`⏰ Connection timeout after ${Math.round(elapsedTime/1000)} seconds`);
            
            // Create timeout error using modern object syntax
            const timeoutError = {
                type: 'network',
                message: 'Connection attempt timed out - this usually indicates network connectivity issues'
            };
            
            handleConnectionError(timeoutError);
            
            // Cleanup connection using modern conditional assignment
            if (connection && !connection.open) {
                connection = null;
                window.connection = null;
            }
            
            // Offer retry if attempts remaining
            const remainingAttempts = MAX_RETRIES - retryCount;
            if (remainingAttempts > 0) {
                addSystemMessage(`💡 ${remainingAttempts} retry attempts remaining`);
            } else {
                const maxRetryMessages = [
                    '❌ Maximum retry attempts reached',
                    '💡 Try refreshing the page or connecting from a different network'
                ];
                maxRetryMessages.forEach(msg => addSystemMessage(msg));
            }
        };
        
        /**
         * Initiates an outgoing connection to a specified peer
         * @param {string} peerId - The ID of the peer to connect to
         * @returns {Object|null} The connection object or null if peer not initialized
         */
        const initiateConnection = (peerId) => {
            if (!peer) {
                addSystemMessage('Peer not initialized');
                return null;
            }
            
            // Record connection start time for performance monitoring
            recordConnectionStart();
            
            // Create connection to target peer
            const conn = peer.connect(peerId);
            
            // Store connection globally using modern assignment
            Object.assign(window, { connection: conn });
            connection = conn;
            
            // Setup connection event handlers
            setupConnectionHandlers(conn);
            
            return conn;
        };
        
        /**
         * Handles incoming connection requests from other peers
         * @param {Object} conn - The incoming connection object from PeerJS
         */
        const handleIncomingConnection = (conn) => {
            // Store the incoming connection using modern assignment
            Object.assign(window, { connection: conn });
            connection = conn;
            
            // Setup connection event handlers
            setupConnectionHandlers(conn);
        };
        
        /**
         * Sets up event handlers for a connection (both incoming and outgoing)
         * @param {Object} conn - The connection object to set up handlers for
         */
        const setupConnectionHandlers = (conn) => {
            // Handle connection open event with arrow function
            conn.on('open', () => {
                handleConnectionOpen();
                
                // Clear connection timeout on successful connection
                if (connectionTimeout) {
                    clearTimeout(connectionTimeout);
                    connectionTimeout = null;
                }
                
                // Reset retry count on successful connection
                retryCount = 0;
                
                // Calculate connection time using modern conditional logic
                if (connectionStartTime) {
                    const connectionTime = Date.now() - connectionStartTime;
                    addSystemMessage(`⚡ Connection established in ${Math.round(connectionTime/1000)} seconds`);
                }
            });
            
            // Handle incoming data (messages) with arrow function
            conn.on('data', (data) => {
                handleReceivedMessage(data);
            });
            
            // Handle connection close event with arrow function
            conn.on('close', () => {
                handleConnectionClose();
            });
            
            // Handle connection errors with enhanced error detection
            conn.on('error', (err) => {
                console.error('Connection error:', err);
                
                // Enhance error with network-specific information
                const enhancedError = enhanceConnectionError(err);
                handleConnectionError(enhancedError);
            });
            
            // Monitor ICE connection state changes for better error reporting
            if (conn.peerConnection) {
                conn.peerConnection.oniceconnectionstatechange = () => {
                    const state = conn.peerConnection.iceConnectionState;
                    handleICEConnectionStateChange(state);
                };
                
                conn.peerConnection.onconnectionstatechange = () => {
                    const state = conn.peerConnection.connectionState;
                    handleConnectionStateChange(state);
                };
            }
        };
        
        /**
         * Enhances connection errors with network-specific information
         * @param {Object} error - The original error object
         * @returns {Object} Enhanced error object with network context
         */
        const enhanceConnectionError = (error) => {
            const enhanced = { ...error };
            
            // Detect common network-related error patterns using modern Map
            if (error.message) {
                const message = error.message.toLowerCase();
                
                const errorPatterns = new Map([
                    [['ice', 'stun', 'turn'], 'ice-connection-failed'],
                    [['timeout', 'timed out'], 'network'],
                    [['peer', 'unavailable'], 'peer-unavailable'],
                    [['server', 'signaling'], 'server-error'],

                ]);
                
                for (const [patterns, errorType] of errorPatterns) {
                    if (patterns.some(pattern => message.includes(pattern))) {
                        enhanced.type = errorType;
                        break;
                    }
                }
            }
            
            return enhanced;
        };
        
        /**
         * Handles ICE connection state changes for detailed network diagnostics
         * @param {string} state - The ICE connection state
         */
        const handleICEConnectionStateChange = (state) => {
            const stateHandlers = new Map([
                ['checking', () => showConnectionProgress(50, 'Checking network connectivity...')],
                ['connected', () => showConnectionProgress(90, 'Network path established...')],
                ['completed', () => showConnectionProgress(100, 'Connection optimized!')],
                ['failed', () => {
                    const iceError = {
                        type: 'ice-connection-failed',
                        message: 'ICE connection failed - unable to establish network path'
                    };
                    handleConnectionError(iceError);
                }],
                ['disconnected', () => {
                    updateConnectionStatus('error', 'Network Disconnected');
                    addSystemMessage('🌐 Network connection lost - attempting to reconnect...');
                }],
                ['closed', () => updateConnectionStatus('disconnected', 'Connection Closed')]
            ]);
            
            const handler = stateHandlers.get(state);
            if (handler) handler();
        };
        
        /**
         * Handles general connection state changes
         * @param {string} state - The connection state
         */
        const handleConnectionStateChange = (state) => {
            const stateHandlers = new Map([
                ['connecting', () => showConnectionProgress(40, 'Establishing secure connection...')],
                ['connected', () => hideConnectionProgress()],
                ['failed', () => {
                    const connError = {
                        type: 'network',
                        message: 'Connection failed - network path could not be established'
                    };
                    handleConnectionError(connError);
                }]
            ]);
            
            const handler = stateHandlers.get(state);
            if (handler) handler();
        };
        
        /**
         * Handles the connection open event when a connection is successfully established
         */
        const handleConnectionOpen = () => {
            // Record connection completion time for performance monitoring
            recordConnectionEnd();
            
            updateConnectionStatus('connected', 'Connected');
            hideNetworkDiagnostics();
            enableSendButton();
            
            // Add connection success message with network info
            addSystemMessage('✅ Peer-to-peer connection established successfully!');
            
            // Start performance monitoring for connection quality
            startPerformanceMonitoring();
            
            // Show connection quality information using modern optional chaining
            if (connection?.peerConnection) {
                setTimeout(() => {
                    showConnectionQualityInfo();
                }, 2000);
            }
            
            // Log performance metrics
            logPerformanceMetrics();
        };
        
        /**
         * Shows connection quality and network information
         */
        const showConnectionQualityInfo = async () => {
            if (!connection?.peerConnection) return;
            
            try {
                const stats = await connection.peerConnection.getStats();
                let hasValidStats = false;
                
                for (const report of stats.values()) {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        hasValidStats = true;
                        addSystemMessage('📊 Connection Quality:');
                        
                        // Modern destructuring and optional chaining
                        const { currentRoundTripTime, availableOutgoingBitrate, localCandidateId, remoteCandidateId } = report;
                        
                        if (currentRoundTripTime) {
                            const rtt = Math.round(currentRoundTripTime * 1000);
                            addSystemMessage(`• Round-trip time: ${rtt}ms`);
                        }
                        
                        if (availableOutgoingBitrate) {
                            const bandwidth = Math.round(availableOutgoingBitrate / 1000);
                            addSystemMessage(`• Available bandwidth: ${bandwidth} kbps`);
                        }
                        
                        // Determine connection type using modern iteration
                        if (localCandidateId && remoteCandidateId) {
                            for (const candidate of stats.values()) {
                                if (candidate.id === localCandidateId) {
                                    addSystemMessage(`• Local connection: ${candidate.candidateType || 'unknown'}`);
                                }
                                if (candidate.id === remoteCandidateId) {
                                    addSystemMessage(`• Remote connection: ${candidate.candidateType || 'unknown'}`);
                                }
                            }
                        }
                        break;
                    }
                }
                
                if (!hasValidStats) {
                    addSystemMessage('📊 Connection established (detailed stats unavailable)');
                }
            } catch (err) {
                console.warn('Could not get connection stats:', err);
            }
        };
        
        /**
         * Enables the send button to allow message sending
         */
        const enableSendButton = () => {
            document.getElementById('send-btn').disabled = false;
        };
        
        /**
         * Disables the send button to prevent message sending
         */
        const disableSendButton = () => {
            document.getElementById('send-btn').disabled = true;
        };
        
        // ===== CONNECTION CLOSURE FUNCTIONS =====
        
        /**
         * Handles the connection close event when a connection is terminated
         */
        const handleConnectionClose = () => {
            updateConnectionStatus('disconnected', 'Disconnected');
            addSystemMessage('🔌 Connection closed by peer');
            cleanupConnection();
        };
        
        /**
         * Cleans up connection state and UI when a connection ends
         */
        const cleanupConnection = () => {
            // Stop performance monitoring
            stopPerformanceMonitoring();
            stopMemoryMonitoring();
            
            // Clear any active timeouts
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            
            // Reset connection state
            connectionStartTime = null;
            
            // Update UI using modern array methods
            const cleanupActions = [
                disableSendButton,
                hideConnectionProgress,
                hideNetworkDiagnostics,
                hidePerformanceMetrics,
                hideConnectionQuality
            ];
            cleanupActions.forEach(action => action());
            
            // Clear connection reference using modern assignment
            Object.assign(window, { connection: null });
            connection = null;
        };
        
        // ===== MESSAGE HANDLING FUNCTIONS =====
        
        /**
         * Handles the send button click event with validation and message sending
         * @returns {boolean} True if message was sent, false if validation failed
         */
        const handleSendClick = () => {
            const messageInput = document.getElementById('message-input');
            const message = messageInput.value.trim();
            
            // Validate input using modern conditional logic
            if (!message) {
                return false;
            }
            
            // Check if connected using optional chaining
            if (!connection?.open) {
                addSystemMessage('Not connected to any peer');
                return false;
            }
            
            // Send message
            sendMessage(message, connection);
            
            // Clear input
            messageInput.value = '';
            
            return true;
        };
        
        /**
         * Sends a message through the specified connection and adds it to chat log
         * @param {string} message - The message text to send
         * @param {Object} conn - The connection object to send the message through
         */
        const sendMessage = (message, conn) => {
            // Send message through connection
            conn.send(message);
            
            // Add to chat log with "Me:" prefix
            addMessageToChat(message, 'me');
        };
        
        /**
         * Handles received messages from the connected peer
         * @param {string} message - The received message text
         */
        const handleReceivedMessage = (message) => {
            // Add received message to chat log with "Peer:" prefix
            addMessageToChat(message, 'peer');
        };
        
        /**
         * Adds a formatted message to the chat log with appropriate prefix
         * @param {string} message - The message text to add
         * @param {string} sender - The sender type ('me', 'peer', 'system')
         */
        const addMessageToChat = (message, sender) => {
            const chatLog = document.getElementById('chat-log');
            
            // Modern Map-based prefix lookup
            const prefixes = new Map([
                ['me', 'Me:'],
                ['peer', 'Peer:'],
                ['system', 'System:']
            ]);
            
            const prefix = prefixes.get(sender) ?? 'Unknown:';
            const formattedMessage = `${prefix} ${message}\n`;
            
            chatLog.value += formattedMessage;
            chatLog.scrollTop = chatLog.scrollHeight;
        };
        
        /**
         * Handles keypress events in the message input field (Enter to send)
         * @param {KeyboardEvent} event - The keyboard event object
         */
        const handleMessageInputKeyPress = (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSendClick();
            }
        };
        
        // ===== PEERJS INITIALIZATION =====
        
        /**
         * Initializes the PeerJS instance with modern async/await and ES2020+ features
         * Uses Safari 14+ modern WebRTC features and native JavaScript improvements
         */
        const initializePeer = async () => {
            // Check secure context and WebRTC support before initialization
            if (!checkSecureContext()) {
                // Continue with limited functionality warning
            }
            
            if (!checkWebRTCSupport()) {
                addSystemMessage('❌ Cannot initialize peer connection - WebRTC not supported.');
                return;
            }
            
            // Check if WebRTC is being blocked
            if (detectWebRTCBlocking()) {
                addSystemMessage('⚠️ WebRTC functionality may be limited.');
            }
            
            // Validate all external resources are using HTTPS
            validateHTTPSResources();
            
            try {
                // Modern configuration using destructuring and spread operator
                const peerConfig = {
                    config: {
                        iceServers: [
                            { urls: CONFIG.STUN_SERVER }
                        ],
                        // Modern WebRTC configuration for Safari 14+ and Chrome 88+
                        iceCandidatePoolSize: 10,
                        bundlePolicy: 'max-bundle',
                        rtcpMuxPolicy: 'require',
                        // Use modern DTLS for better security
                        iceTransportPolicy: 'all'
                    },
                    // Modern debugging configuration
                    debug: window.location.hostname === 'localhost' ? 2 : 0
                };
                
                // Create PeerJS instance with modern error handling
                peer = new Peer(peerConfig);
                
                // Store peer globally for testing using modern assignment
                Object.assign(window, { peer });
                
                // Modern event handling with arrow functions and optional chaining
                peer.on('open', (id) => {
                    updateMyId(id);
                    addSystemMessage('✅ Your ID is ready; share it with your peer.');
                    
                    // Modern conditional logic with nullish coalescing
                    const protocol = window.location.protocol;
                    const isSecure = protocol === 'https:';
                    
                    if (isSecure) {
                        addSystemMessage('🔒 Running in secure HTTPS context - full WebRTC functionality available.');
                    }
                    
                    // Modern performance monitoring
                    if (CONFIG.PERFORMANCE_MONITORING) {
                        recordPageLoadTime();
                    }
                });
                
                // Handle incoming connections with modern syntax
                peer.on('connection', (conn) => {
                    addSystemMessage(`📞 Incoming connection from: ${conn.peer}`);
                    handleIncomingConnection(conn);
                });
                
                // Enhanced error handling with modern Map lookup and optional chaining
                peer.on('error', (err) => {
                    console.error('PeerJS Error:', err);
                    
                    // Use nullish coalescing and optional chaining (ES2020)
                    const errorType = err?.type ?? 'unknown';
                    const errorMessage = err?.message ?? 'Unknown peer error';
                    
                    handleHTTPSError({ type: errorType, message: errorMessage });
                    handlePeerError({ type: errorType, message: errorMessage });
                });
                
                // Modern event handling for connection state monitoring
                peer.on('disconnected', () => {
                    addSystemMessage('⚠️ Disconnected from signaling server - attempting reconnect...');
                    
                    // Modern reconnection with exponential backoff using async/await
                    setTimeout(async () => {
                        if (!peer.destroyed) {
                            try {
                                await peer.reconnect();
                                addSystemMessage('✅ Reconnected to signaling server');
                            } catch (reconnectError) {
                                console.error('Reconnection failed:', reconnectError);
                                addSystemMessage('❌ Failed to reconnect - please refresh the page');
                            }
                        }
                    }, 1000);
                });
                
                console.log('✅ PeerJS initialized with modern configuration');
                
            } catch (error) {
                console.error('❌ Failed to initialize PeerJS:', error);
                handleHTTPSError(error);
                addSystemMessage(`❌ Failed to initialize peer connection: ${error?.message ?? 'Unknown error'}`);
                
                // Modern error recovery with exponential backoff
                setTimeout(() => initializePeer(), 5000);
            }
        };
        
        // ===== EVENT LISTENERS SETUP =====
        
        /**
         * Sets up all DOM event listeners for user interactions
         */
        const setupEventListeners = () => {
            // Modern event listener setup using destructuring and array methods
            const eventListeners = [
                ['connect-btn', 'click', handleConnectClick],
                ['retry-btn', 'click', handleRetryClick],
                ['send-btn', 'click', handleSendClick],
                ['message-input', 'keypress', handleMessageInputKeyPress]
            ];
            
            eventListeners.forEach(([elementId, event, handler]) => {
                document.getElementById(elementId).addEventListener(event, handler);
            });
            
            // Network connectivity monitoring with arrow functions
            window.addEventListener('online', () => {
                addSystemMessage('🌐 Network connectivity restored');
                updateConnectionStatus('disconnected', 'Network Online');
            });
            
            window.addEventListener('offline', () => {
                addSystemMessage('📵 Network connectivity lost');
                updateConnectionStatus('error', 'Network Offline');
                
                if (connection?.open) {
                    addSystemMessage('⚠️ Active connection may be affected');
                }
            });
        };
        
        // ===== APPLICATION INITIALIZATION =====
        
        /**
         * Main application initialization function
         * Initializes PeerJS and sets up event listeners
         */
        const initializeApplication = () => {
            // Initialize connection status
            updateConnectionStatus('disconnected', 'Initializing...');
            
            // Start memory monitoring
            startMemoryMonitoring();
            
            // Display HTTPS deployment status
            addSystemMessage('🚀 WebRTC PeerJS Chat - Initializing...');
            
            // Modern conditional messaging using ternary and template literals
            const isHttps = window.location.protocol === 'https:';
            const httpsMessages = isHttps 
                ? ['✅ Running in secure HTTPS context.', '🌐 Full WebRTC functionality available.']
                : ['⚠️ Running in HTTP context.', '💡 For production use, deploy to HTTPS (GitHub Pages).'];
            
            httpsMessages.forEach(msg => addSystemMessage(msg));
            
            // Check secure context using modern conditional logic
            const secureContextMessage = window.isSecureContext
                ? '🔒 Secure context confirmed - WebRTC APIs available.'
                : '⚠️ Non-secure context - WebRTC functionality may be limited.';
            
            addSystemMessage(secureContextMessage);
            
            // Run initial network diagnostics with modern array methods
            const initialDiagnostics = runNetworkDiagnostics();
            const hasErrors = initialDiagnostics.some(({ type }) => type === 'error');
            
            if (hasErrors) {
                addSystemMessage('⚠️ Network issues detected - check diagnostics below');
                showNetworkDiagnostics(initialDiagnostics);
            }
            
            initializePeer();
            setupEventListeners();
        };
        
        /**
         * Initializes the test framework and displays results
         */
        const initializeTestFramework = () => {
            setTimeout(() => {
                // Display initial sync test results
                if (totalAsyncTests === 0) {
                    displayTestResults();
                }
            }, 1000);
        };
        
        // Initialize application when DOM is ready using modern patterns
        const initializeWhenReady = () => {
            // Record page load completion time
            recordPageLoadTime();
            
            initializeApplication();
            initializeTestFramework();
        };
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeWhenReady);
        } else {
            // DOM is already ready
            initializeWhenReady();
        }
        
        // Additional performance optimization: record when all resources are loaded
        window.addEventListener('load', () => {
            // Log final performance metrics after all resources are loaded
            setTimeout(() => {
                logPerformanceMetrics();
            }, 1000);
        });
        
    </script>
</body>
</html>