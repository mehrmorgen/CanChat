<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC PeerJS Chat</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .section h3 {
            margin-top: 0;
            color: #555;
        }
        
        input, button, textarea {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        #chat-log {
            width: 100%;
            height: 200px;
            resize: vertical;
            font-family: monospace;
            background-color: #f8f9fa;
        }
        
        #my-id {
            font-weight: bold;
            color: #28a745;
            padding: 5px;
            background-color: #d4edda;
            border-radius: 4px;
        }
        
        .test-results {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .test-pass {
            color: #28a745;
        }
        
        .test-fail {
            color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC PeerJS Chat</h1>
        
        <div class="section">
            <h3>Your Peer ID</h3>
            <div id="my-id">Connecting...</div>
        </div>
        
        <div class="section">
            <h3>Connect to Peer</h3>
            <input type="text" id="peer-id-input" placeholder="Enter peer ID to connect">
            <button id="connect-btn">Connect</button>
        </div>
        
        <div class="section">
            <h3>Chat</h3>
            <textarea id="chat-log" readonly placeholder="Chat messages will appear here..."></textarea>
            <div>
                <input type="text" id="message-input" placeholder="Type your message...">
                <button id="send-btn" disabled>Send</button>
            </div>
        </div>
        
        <div class="test-results">
            <h3>Test Results</h3>
            <div id="test-output"></div>
        </div>
    </div>

    <!-- Jest Testing Framework -->
    <script src="https://unpkg.com/jest-lite@1.0.0-alpha.4/dist/core.js"></script>
    
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    
    <script>
        // ===== TESTING FRAMEWORK SETUP =====
        
        // Simple test framework setup
        let testResults = [];
        let testOutput = document.getElementById('test-output');
        let asyncTestsCompleted = 0;
        let totalAsyncTests = 0;
        
        function describe(description, testSuite) {
            console.log(`\n=== ${description} ===`);
            testSuite();
        }
        
        function test(description, testFunction) {
            try {
                testFunction();
                testResults.push({ description, status: 'PASS', error: null });
                console.log(`✓ ${description}`);
            } catch (error) {
                testResults.push({ description, status: 'FAIL', error: error.message });
                console.log(`✗ ${description}: ${error.message}`);
            }
        }
        
        function asyncTest(description, testFunction, timeout = 5000) {
            totalAsyncTests++;
            setTimeout(() => {
                try {
                    testFunction();
                    testResults.push({ description, status: 'PASS', error: null });
                    console.log(`✓ ${description}`);
                } catch (error) {
                    testResults.push({ description, status: 'FAIL', error: error.message });
                    console.log(`✗ ${description}: ${error.message}`);
                }
                asyncTestsCompleted++;
                if (asyncTestsCompleted === totalAsyncTests) {
                    displayTestResults();
                }
            }, timeout);
        }
        
        function expect(actual) {
            return {
                toBe: (expected) => {
                    if (actual !== expected) {
                        throw new Error(`Expected ${expected}, but got ${actual}`);
                    }
                },
                toBeNull: () => {
                    if (actual !== null) {
                        throw new Error(`Expected null, but got ${actual}`);
                    }
                },
                not: {
                    toBeNull: () => {
                        if (actual === null) {
                            throw new Error(`Expected not null, but got null`);
                        }
                    }
                },
                toBeTruthy: () => {
                    if (!actual) {
                        throw new Error(`Expected truthy value, but got ${actual}`);
                    }
                },
                toContain: (expected) => {
                    if (!actual.includes(expected)) {
                        throw new Error(`Expected "${actual}" to contain "${expected}"`);
                    }
                }
            };
        }
        
        function displayTestResults() {
            const passCount = testResults.filter(r => r.status === 'PASS').length;
            const failCount = testResults.filter(r => r.status === 'FAIL').length;
            
            let html = `<strong>Tests: ${passCount} passed, ${failCount} failed</strong><br><br>`;
            
            testResults.forEach(result => {
                const className = result.status === 'PASS' ? 'test-pass' : 'test-fail';
                html += `<div class="${className}">`;
                html += `${result.status === 'PASS' ? '✓' : '✗'} ${result.description}`;
                if (result.error) {
                    html += ` - ${result.error}`;
                }
                html += `</div>`;
            });
            
            testOutput.innerHTML = html;
        }
        
        // ===== INITIAL FAILING TESTS =====
        
        describe('DOM Element Existence Tests', () => {
            test('should have my-id element', () => {
                const element = document.getElementById('my-id');
                expect(element).not.toBeNull();
            });
            
            test('should have peer-id-input element', () => {
                const element = document.getElementById('peer-id-input');
                expect(element).not.toBeNull();
            });
            
            test('should have connect-btn element', () => {
                const element = document.getElementById('connect-btn');
                expect(element).not.toBeNull();
            });
            
            test('should have chat-log element', () => {
                const element = document.getElementById('chat-log');
                expect(element).not.toBeNull();
            });
            
            test('should have message-input element', () => {
                const element = document.getElementById('message-input');
                expect(element).not.toBeNull();
            });
            
            test('should have send-btn element', () => {
                const element = document.getElementById('send-btn');
                expect(element).not.toBeNull();
            });
        });
        
        describe('Basic Structure Tests', () => {
            test('should have correct page title', () => {
                expect(document.title).toBe('WebRTC PeerJS Chat');
            });
            
            test('should have main heading', () => {
                const heading = document.querySelector('h1');
                expect(heading).not.toBeNull();
                expect(heading.textContent).toContain('WebRTC PeerJS Chat');
            });
            
            test('should have send button initially disabled', () => {
                const sendBtn = document.getElementById('send-btn');
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should have chat-log as textarea', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.tagName.toLowerCase()).toBe('textarea');
            });
            
            test('should have peer-id-input as input field', () => {
                const peerInput = document.getElementById('peer-id-input');
                expect(peerInput.tagName.toLowerCase()).toBe('input');
            });
        });
        
        describe('CSS and Styling Tests', () => {
            test('should have basic styling applied', () => {
                const body = document.body;
                const computedStyle = window.getComputedStyle(body);
                expect(computedStyle.fontFamily).toContain('Arial');
            });
            
            test('should have container with proper styling', () => {
                const container = document.querySelector('.container');
                expect(container).not.toBeNull();
                const computedStyle = window.getComputedStyle(container);
                expect(computedStyle.backgroundColor).toBe('rgb(255, 255, 255)');
            });
        });
        
        describe('External Library Tests', () => {
            test('should have PeerJS library loaded', () => {
                expect(typeof Peer).toBe('function');
            });
        });
        
        // ===== PEERJS INITIALIZATION TESTS =====
        
        describe('PeerJS Initialization Tests', () => {
            test('should initially display "Connecting..." in my-id element', () => {
                const myIdElement = document.getElementById('my-id');
                expect(myIdElement.textContent).toBe('Connecting...');
            });
            
            test('should have empty chat log initially', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.value).toBe('');
            });
            
            test('should have helper functions defined', () => {
                expect(typeof addSystemMessage).toBe('function');
                expect(typeof updateMyId).toBe('function');
                expect(typeof initializePeer).toBe('function');
            });
            
            test('addSystemMessage function should work correctly', () => {
                const chatLog = document.getElementById('chat-log');
                const initialValue = chatLog.value;
                addSystemMessage('Test message');
                expect(chatLog.value).toContain('System: Test message');
                expect(chatLog.value.length).toBe(initialValue.length + 'System: Test message\n'.length);
            });
            
            test('updateMyId function should work correctly', () => {
                const myIdElement = document.getElementById('my-id');
                updateMyId('test-id-123');
                expect(myIdElement.textContent).toBe('test-id-123');
                expect(window.myId).toBe('test-id-123');
                // Reset for other tests
                myIdElement.textContent = 'Connecting...';
                window.myId = null;
            });
        });
        
        // ===== ASYNC PEERJS TESTS =====
        
        describe('PeerJS Async Behavior Tests', () => {
            asyncTest('should create PeerJS instance after initialization', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer instanceof Peer).toBe(true);
            }, 1000);
            
            asyncTest('should configure PeerJS with Google STUN server', () => {
                expect(window.peer).not.toBeNull();
                expect(window.peer._options).not.toBeNull();
                expect(window.peer._options.config).not.toBeNull();
                expect(window.peer._options.config.iceServers).not.toBeNull();
                expect(window.peer._options.config.iceServers.length).toBe(1);
                expect(window.peer._options.config.iceServers[0].urls).toBe('stun:stun.l.google.com:19302');
            }, 1000);
            
            asyncTest('should update peer ID display when ready', () => {
                const myIdElement = document.getElementById('my-id');
                // Should no longer show "Connecting..." after peer is ready
                expect(myIdElement.textContent).not.toBe('Connecting...');
                expect(myIdElement.textContent.length).toBe(16); // PeerJS generates 16-character IDs
            }, 3000);
            
            asyncTest('should add system message when peer ID is ready', () => {
                const chatLog = document.getElementById('chat-log');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
            }, 3000);
            
            asyncTest('should set global myId variable when ready', () => {
                expect(window.myId).not.toBeNull();
                expect(typeof window.myId).toBe('string');
                expect(window.myId.length).toBe(16);
            }, 3000);
        });
        
        // ===== MESSAGE HANDLING TESTS (FAILING) =====
        
        describe('Send Button Click Handler Tests', () => {
            test('should have handleSendClick function defined', () => {
                expect(typeof handleSendClick).toBe('function');
            });
            
            test('should not send empty messages', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = '';
                const result = handleSendClick();
                expect(result).toBe(false);
            });
            
            test('should not send messages when not connected', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                window.connection = null;
                const result = handleSendClick();
                expect(result).toBe(false);
            });
            
            test('should send message when connected with valid input', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                // Mock connection for testing
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const result = handleSendClick();
                expect(result).toBe(true);
                expect(mockConnection.lastSentData).toBe('test message');
            });
            
            test('should clear message input after sending', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {}
                };
                window.connection = mockConnection;
                
                handleSendClick();
                expect(messageInput.value).toBe('');
            });
        });
        
        describe('Message Sending Tests', () => {
            test('should have sendMessage function defined', () => {
                expect(typeof sendMessage).toBe('function');
            });
            
            test('should send message through connection', () => {
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                
                sendMessage('Hello World', mockConnection);
                expect(mockConnection.lastSentData).toBe('Hello World');
            });
            
            test('should add sent message to chat log with "Me:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockConnection = {
                    open: true,
                    send: function(data) {}
                };
                
                sendMessage('Hello World', mockConnection);
                expect(chatLog.value).toContain('Me: Hello World');
                expect(chatLog.value.length).toBe(initialLength + 'Me: Hello World\n'.length);
            });
        });
        
        describe('Message Receiving Tests', () => {
            test('should have handleReceivedMessage function defined', () => {
                expect(typeof handleReceivedMessage).toBe('function');
            });
            
            test('should add received message to chat log with "Peer:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                handleReceivedMessage('Hello from peer');
                expect(chatLog.value).toContain('Peer: Hello from peer');
                expect(chatLog.value.length).toBe(initialLength + 'Peer: Hello from peer\n'.length);
            });
        });
        
        describe('Message Formatting Tests', () => {
            test('should have addMessageToChat function defined', () => {
                expect(typeof addMessageToChat).toBe('function');
            });
            
            test('should format message with "Me:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'me');
                expect(chatLog.value).toContain('Me: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'Me: Test message\n'.length);
            });
            
            test('should format message with "Peer:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'peer');
                expect(chatLog.value).toContain('Peer: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'Peer: Test message\n'.length);
            });
            
            test('should format message with "System:" prefix', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                addMessageToChat('Test message', 'system');
                expect(chatLog.value).toContain('System: Test message');
                expect(chatLog.value.length).toBe(initialLength + 'System: Test message\n'.length);
            });
        });
        
        describe('Chat Log Update Tests', () => {
            test('should scroll chat log to bottom after adding message', () => {
                const chatLog = document.getElementById('chat-log');
                
                // Add multiple messages to create scrollable content
                for (let i = 0; i < 20; i++) {
                    addMessageToChat(`Message ${i}`, 'me');
                }
                
                // Check that scroll position is at bottom
                expect(chatLog.scrollTop).toBe(chatLog.scrollHeight - chatLog.clientHeight);
            });
            
            test('should maintain message history in chat log', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = ''; // Clear for this test
                
                addMessageToChat('First message', 'me');
                addMessageToChat('Second message', 'peer');
                addMessageToChat('Third message', 'system');
                
                expect(chatLog.value).toContain('Me: First message');
                expect(chatLog.value).toContain('Peer: Second message');
                expect(chatLog.value).toContain('System: Third message');
                
                // Check order is maintained
                const lines = chatLog.value.split('\n').filter(line => line.trim());
                expect(lines[0]).toBe('Me: First message');
                expect(lines[1]).toBe('Peer: Second message');
                expect(lines[2]).toBe('System: Third message');
            });
        });
        
        describe('Enter Key Message Sending Tests', () => {
            test('should have handleMessageInputKeyPress function defined', () => {
                expect(typeof handleMessageInputKeyPress).toBe('function');
            });
            
            test('should send message on Enter key press', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const mockEvent = {
                    key: 'Enter',
                    preventDefault: function() {}
                };
                
                handleMessageInputKeyPress(mockEvent);
                expect(mockConnection.lastSentData).toBe('test message');
                expect(messageInput.value).toBe('');
            });
            
            test('should not send message on other key presses', () => {
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'test message';
                
                const mockConnection = {
                    open: true,
                    send: function(data) {
                        this.lastSentData = data;
                    }
                };
                window.connection = mockConnection;
                
                const mockEvent = {
                    key: 'a',
                    preventDefault: function() {}
                };
                
                handleMessageInputKeyPress(mockEvent);
                expect(mockConnection.lastSentData).toBe(undefined);
                expect(messageInput.value).toBe('test message');
            });
        });
        
        // ===== CONNECTION ESTABLISHMENT TESTS (FAILING) =====
        
        describe('Connection Button Click Handler Tests', () => {
            test('should have handleConnectClick function defined', () => {
                expect(typeof handleConnectClick).toBe('function');
            });
            
            test('should prevent connection with empty peer ID', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = '';
                const result = handleConnectClick();
                expect(result).toBe(false);
            });
            
            test('should prevent self-connection', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                // Set a mock peer ID for testing
                window.myId = 'test-peer-id';
                peerIdInput.value = 'test-peer-id';
                const result = handleConnectClick();
                expect(result).toBe(false);
            });
            
            test('should initiate connection with valid peer ID', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'my-test-id';
                peerIdInput.value = 'other-peer-id';
                const result = handleConnectClick();
                expect(result).toBe(true);
            });
        });
        
        describe('Outgoing Connection Establishment Tests', () => {
            test('should have initiateConnection function defined', () => {
                expect(typeof initiateConnection).toBe('function');
            });
            
            test('should create connection when peer is available', () => {
                // Mock peer object for testing
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                const conn = initiateConnection('test-peer-id');
                expect(conn).not.toBeNull();
                expect(conn.peer).toBe('test-peer-id');
            });
            
            test('should store connection globally', () => {
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                initiateConnection('test-peer-id');
                expect(window.connection).not.toBeNull();
            });
        });
        
        describe('Incoming Connection Handling Tests', () => {
            test('should have handleIncomingConnection function defined', () => {
                expect(typeof handleIncomingConnection).toBe('function');
            });
            
            test('should accept incoming connection', () => {
                const mockConnection = { peer: 'incoming-peer-id', open: false };
                handleIncomingConnection(mockConnection);
                expect(window.connection).toBe(mockConnection);
            });
            
            test('should setup connection event handlers for incoming connection', () => {
                const mockConnection = { 
                    peer: 'incoming-peer-id', 
                    open: false,
                    on: function(event, handler) {
                        this['_' + event] = handler;
                    }
                };
                handleIncomingConnection(mockConnection);
                expect(typeof mockConnection._open).toBe('function');
                expect(typeof mockConnection._data).toBe('function');
                expect(typeof mockConnection._close).toBe('function');
            });
        });
        
        describe('Connection Open Event Tests', () => {
            test('should have handleConnectionOpen function defined', () => {
                expect(typeof handleConnectionOpen).toBe('function');
            });
            
            test('should add connection established message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                handleConnectionOpen();
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(chatLog.value.length).toBe(initialLength + 'System: ⚡ Connection established\n'.length);
            });
            
            test('should enable send button when connection opens', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = true; // Ensure it starts disabled
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
            });
        });
        
        describe('Send Button State Management Tests', () => {
            test('should have enableSendButton function defined', () => {
                expect(typeof enableSendButton).toBe('function');
            });
            
            test('should have disableSendButton function defined', () => {
                expect(typeof disableSendButton).toBe('function');
            });
            
            test('enableSendButton should enable the send button', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = true;
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
            });
            
            test('disableSendButton should disable the send button', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== INPUT VALIDATION AND ERROR HANDLING TESTS (FAILING) =====
        
        describe('Empty Peer ID Validation Tests', () => {
            test('should have validatePeerIdInput function defined', () => {
                expect(typeof validatePeerIdInput).toBe('function');
            });
            
            test('should return false for empty peer ID', () => {
                const result = validatePeerIdInput('');
                expect(result).toBe(false);
            });
            
            test('should return false for whitespace-only peer ID', () => {
                const result = validatePeerIdInput('   ');
                expect(result).toBe(false);
            });
            
            test('should return true for valid peer ID', () => {
                const result = validatePeerIdInput('valid-peer-id');
                expect(result).toBe(true);
            });
            
            test('should show error message for empty peer ID in connect handler', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                peerIdInput.value = '';
                handleConnectClick();
                
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                expect(chatLog.value.length).toBe(initialLength + 'System: Please enter a peer ID to connect\n'.length);
            });
        });
        
        describe('Self-Connection Prevention Tests', () => {
            test('should have validateSelfConnection function defined', () => {
                expect(typeof validateSelfConnection).toBe('function');
            });
            
            test('should return false when trying to connect to self', () => {
                window.myId = 'test-peer-id';
                const result = validateSelfConnection('test-peer-id');
                expect(result).toBe(false);
            });
            
            test('should return true when connecting to different peer', () => {
                window.myId = 'my-peer-id';
                const result = validateSelfConnection('other-peer-id');
                expect(result).toBe(true);
            });
            
            test('should show error message for self-connection attempt', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                window.myId = 'test-peer-id';
                peerIdInput.value = 'test-peer-id';
                handleConnectClick();
                
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                expect(chatLog.value.length).toBe(initialLength + 'System: Cannot connect to yourself\n'.length);
            });
        });
        
        describe('Connection Failure Error Handling Tests', () => {
            test('should have handleConnectionError function defined', () => {
                expect(typeof handleConnectionError).toBe('function');
            });
            
            test('should display user-friendly error message for connection failures', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'peer-unavailable', message: 'Could not connect to peer' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Peer not found or unavailable');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Peer not found or unavailable\n'.length);
            });
            
            test('should handle network error with appropriate message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'network', message: 'Network error occurred' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Network error - please check your internet connection');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Network error - please check your internet connection\n'.length);
            });
            
            test('should handle generic connection error with fallback message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { message: 'Unknown error' };
                handleConnectionError(mockError);
                
                expect(chatLog.value).toContain('System: Connection failed: Unknown error');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection failed: Unknown error\n'.length);
            });
        });
        
        describe('PeerJS Error Handling Tests', () => {
            test('should have handlePeerError function defined', () => {
                expect(typeof handlePeerError).toBe('function');
            });
            
            test('should handle peer-unavailable error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'peer-unavailable', message: 'Could not connect to peer' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Peer not found - please check the peer ID and try again');
                expect(chatLog.value.length).toBe(initialLength + 'System: Peer not found - please check the peer ID and try again\n'.length);
            });
            
            test('should handle network error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'network', message: 'Network connection failed' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Network error - please check your internet connection and try again');
                expect(chatLog.value.length).toBe(initialLength + 'System: Network error - please check your internet connection and try again\n'.length);
            });
            
            test('should handle server-error with user-friendly message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { type: 'server-error', message: 'PeerJS server error' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: Server error - please try again later');
                expect(chatLog.value.length).toBe(initialLength + 'System: Server error - please try again later\n'.length);
            });
            
            test('should handle generic PeerJS error with fallback message', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                const mockError = { message: 'Generic PeerJS error' };
                handlePeerError(mockError);
                
                expect(chatLog.value).toContain('System: An error occurred: Generic PeerJS error');
                expect(chatLog.value.length).toBe(initialLength + 'System: An error occurred: Generic PeerJS error\n'.length);
            });
        });
        
        // ===== CODE ORGANIZATION AND DOCUMENTATION TESTS =====
        
        describe('Code Organization Tests', () => {
            test('should have all required function sections defined', () => {
                // Test that all major function categories exist
                expect(typeof addSystemMessage).toBe('function');
                expect(typeof updateMyId).toBe('function');
                expect(typeof validatePeerIdInput).toBe('function');
                expect(typeof validateSelfConnection).toBe('function');
                expect(typeof handleConnectionError).toBe('function');
                expect(typeof handlePeerError).toBe('function');
                expect(typeof handleConnectClick).toBe('function');
                expect(typeof initiateConnection).toBe('function');
                expect(typeof handleIncomingConnection).toBe('function');
                expect(typeof setupConnectionHandlers).toBe('function');
                expect(typeof handleConnectionOpen).toBe('function');
                expect(typeof enableSendButton).toBe('function');
                expect(typeof disableSendButton).toBe('function');
                expect(typeof handleConnectionClose).toBe('function');
                expect(typeof cleanupConnection).toBe('function');
                expect(typeof handleSendClick).toBe('function');
                expect(typeof sendMessage).toBe('function');
                expect(typeof handleReceivedMessage).toBe('function');
                expect(typeof addMessageToChat).toBe('function');
                expect(typeof handleMessageInputKeyPress).toBe('function');
                expect(typeof initializePeer).toBe('function');
                expect(typeof setupEventListeners).toBe('function');
            });
            
            test('should have proper function documentation', () => {
                // Test that functions have proper JSDoc-style comments
                const scriptContent = document.querySelector('script:last-of-type').textContent;
                
                // Check for function documentation patterns
                expect(scriptContent).toContain('/**');
                expect(scriptContent).toContain(' * ');
                expect(scriptContent).toContain(' */');
            });
            
            test('should have clear section organization with comments', () => {
                const scriptContent = document.querySelector('script:last-of-type').textContent;
                
                // Check for section headers
                expect(scriptContent).toContain('// ===== TESTING FRAMEWORK SETUP =====');
                expect(scriptContent).toContain('// ===== APPLICATION VARIABLES =====');
                expect(scriptContent).toContain('// ===== HELPER FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== INPUT VALIDATION FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== ERROR HANDLING FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== CONNECTION ESTABLISHMENT FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== CONNECTION CLOSURE FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== MESSAGE HANDLING FUNCTIONS =====');
                expect(scriptContent).toContain('// ===== PEERJS INITIALIZATION =====');
                expect(scriptContent).toContain('// ===== EVENT LISTENERS SETUP =====');
                expect(scriptContent).toContain('// ===== APPLICATION INITIALIZATION =====');
            });
        });
        
        describe('Helper Function Isolation Tests', () => {
            test('should have pure helper functions that don\'t modify global state directly', () => {
                // Test validatePeerIdInput is pure
                const result1 = validatePeerIdInput('test-id');
                const result2 = validatePeerIdInput('test-id');
                expect(result1).toBe(result2);
                expect(result1).toBe(true);
                
                // Test validateSelfConnection is pure (given same inputs)
                window.myId = 'my-id';
                const selfResult1 = validateSelfConnection('other-id');
                const selfResult2 = validateSelfConnection('other-id');
                expect(selfResult1).toBe(selfResult2);
                expect(selfResult1).toBe(true);
            });
            
            test('should have modular message formatting functions', () => {
                // Test addMessageToChat is modular and reusable
                const chatLog = document.getElementById('chat-log');
                const initialValue = chatLog.value;
                
                addMessageToChat('Test message 1', 'me');
                expect(chatLog.value).toContain('Me: Test message 1');
                
                addMessageToChat('Test message 2', 'peer');
                expect(chatLog.value).toContain('Peer: Test message 2');
                
                addMessageToChat('Test message 3', 'system');
                expect(chatLog.value).toContain('System: Test message 3');
                
                // Reset for other tests
                chatLog.value = initialValue;
            });
            
            test('should have reusable UI state management functions', () => {
                const sendBtn = document.getElementById('send-btn');
                
                // Test enableSendButton is reusable
                sendBtn.disabled = true;
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
                
                // Test disableSendButton is reusable
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should have modular error handling functions', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                // Test handleConnectionError is modular
                const connectionError = { type: 'network', message: 'Network failed' };
                handleConnectionError(connectionError);
                expect(chatLog.value).toContain('Network error - please check your internet connection');
                
                // Test handlePeerError is modular
                const peerError = { type: 'peer-unavailable', message: 'Peer not found' };
                handlePeerError(peerError);
                expect(chatLog.value).toContain('Peer not found - please check the peer ID and try again');
            });
        });
        
        describe('Function Documentation Standards Tests', () => {
            test('should have documented function parameters and return values', () => {
                // This test verifies that key functions have proper documentation
                // by checking their behavior matches documented expectations
                
                // validatePeerIdInput should return boolean
                expect(typeof validatePeerIdInput('test')).toBe('boolean');
                
                // validateSelfConnection should return boolean
                expect(typeof validateSelfConnection('test')).toBe('boolean');
                
                // addMessageToChat should not return anything (void)
                expect(addMessageToChat('test', 'me')).toBe(undefined);
                
                // handleSendClick should return boolean
                expect(typeof handleSendClick()).toBe('boolean');
                
                // handleConnectClick should return boolean
                expect(typeof handleConnectClick()).toBe('boolean');
            });
            
            test('should have functions with clear single responsibilities', () => {
                // Test that functions have single, clear responsibilities
                
                // addSystemMessage should only add system messages
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                addSystemMessage('Test system message');
                expect(chatLog.value).toContain('System: Test system message');
                
                // updateMyId should only update the peer ID display
                const myIdElement = document.getElementById('my-id');
                updateMyId('test-update-id');
                expect(myIdElement.textContent).toBe('test-update-id');
                expect(window.myId).toBe('test-update-id');
                
                // cleanupConnection should only clean up connection state
                window.connection = { open: true };
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                cleanupConnection();
                expect(window.connection).toBeNull();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== CONNECTION CLOSURE TESTS =====
        
        describe('Connection Close Event Handler Tests', () => {
            test('should have handleConnectionClose function defined', () => {
                expect(typeof handleConnectionClose).toBe('function');
            });
            
            test('should add connection closed message to chat log', () => {
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                handleConnectionClose();
                expect(chatLog.value).toContain('System: Connection closed');
                expect(chatLog.value.length).toBe(initialLength + 'System: Connection closed\n'.length);
            });
            
            test('should disable send button when connection closes', () => {
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false; // Ensure it starts enabled
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should clear connection variable when connection closes', () => {
                window.connection = { open: true };
                handleConnectionClose();
                expect(window.connection).toBeNull();
            });
        });
        
        describe('Connection Cleanup Tests', () => {
            test('should have cleanupConnection function defined', () => {
                expect(typeof cleanupConnection).toBe('function');
            });
            
            test('should reset connection state for new connections', () => {
                // Set up a mock connection state
                window.connection = { open: true };
                const sendBtn = document.getElementById('send-btn');
                sendBtn.disabled = false;
                
                cleanupConnection();
                
                expect(window.connection).toBeNull();
                expect(sendBtn.disabled).toBe(true);
            });
            
            test('should allow new connections after cleanup', () => {
                // Simulate connection cleanup
                cleanupConnection();
                
                // Should be able to create new connection
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'my-test-id';
                peerIdInput.value = 'new-peer-id';
                
                // Mock peer for testing
                const mockPeer = {
                    connect: function(peerId) {
                        return { peer: peerId, open: false };
                    }
                };
                window.peer = mockPeer;
                
                const result = handleConnectClick();
                expect(result).toBe(true);
                expect(window.connection).not.toBeNull();
            });
        });
        
        describe('Connection State Management Tests', () => {
            test('should properly handle connection close event in setupConnectionHandlers', () => {
                const mockConnection = {
                    on: function(event, handler) {
                        this['_' + event] = handler;
                    }
                };
                
                setupConnectionHandlers(mockConnection);
                
                // Verify close handler is set up
                expect(typeof mockConnection._close).toBe('function');
                
                // Test that close handler calls handleConnectionClose
                const chatLog = document.getElementById('chat-log');
                const initialLength = chatLog.value.length;
                
                mockConnection._close();
                
                expect(chatLog.value).toContain('System: Connection closed');
            });
            
            test('should handle multiple connection close events gracefully', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = ''; // Clear for this test
                
                // Call handleConnectionClose multiple times
                handleConnectionClose();
                handleConnectionClose();
                
                // Should only add one message per call
                const lines = chatLog.value.split('\n').filter(line => line.trim());
                const closeMessages = lines.filter(line => line.includes('Connection closed'));
                expect(closeMessages.length).toBe(2);
            });
        });
        
        // ===== COMPREHENSIVE INTEGRATION TESTS =====
        
        describe('Complete User Workflow Integration Tests', () => {
            test('should complete full peer ID generation → connection → messaging → closure workflow', () => {
                // Reset state for clean test
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Step 1: Peer ID generation (simulated)
                const testPeerId = 'test-peer-12345';
                updateMyId(testPeerId);
                expect(window.myId).toBe(testPeerId);
                expect(document.getElementById('my-id').textContent).toBe(testPeerId);
                
                // Step 2: System message for peer ready
                addSystemMessage('Your ID is ready; share it with your peer.');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
                
                // Step 3: Connection establishment (simulated)
                const mockConnection = {
                    open: true,
                    peer: 'remote-peer-123',
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                handleConnectionOpen();
                
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(document.getElementById('send-btn').disabled).toBe(false);
                
                // Step 4: Message exchange
                sendMessage('Hello from integration test', mockConnection);
                expect(chatLog.value).toContain('Me: Hello from integration test');
                expect(mockConnection.lastSent).toBe('Hello from integration test');
                
                handleReceivedMessage('Hello back from peer');
                expect(chatLog.value).toContain('Peer: Hello back from peer');
                
                // Step 5: Connection closure
                handleConnectionClose();
                expect(chatLog.value).toContain('System: Connection closed');
                expect(document.getElementById('send-btn').disabled).toBe(true);
                expect(window.connection).toBeNull();
            });
            
            test('should handle multiple connection attempts in sequence', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up peer ID
                window.myId = 'test-peer-seq';
                
                // First connection attempt
                const peerIdInput = document.getElementById('peer-id-input');
                peerIdInput.value = 'peer-1';
                
                const mockPeer1 = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer1;
                
                const result1 = handleConnectClick();
                expect(result1).toBe(true);
                expect(window.connection.peer).toBe('peer-1');
                
                // Simulate connection close
                handleConnectionClose();
                expect(window.connection).toBeNull();
                
                // Second connection attempt
                peerIdInput.value = 'peer-2';
                const result2 = handleConnectClick();
                expect(result2).toBe(true);
                expect(window.connection.peer).toBe('peer-2');
                
                // Verify chat log shows both connection attempts
                expect(chatLog.value).toContain('System: Connection closed');
            });
            
            test('should handle rapid message sending during active connection', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.sentMessages = this.sentMessages || []; this.sentMessages.push(data); },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Send multiple messages rapidly
                const messages = ['Message 1', 'Message 2', 'Message 3', 'Message 4', 'Message 5'];
                messages.forEach(msg => {
                    sendMessage(msg, mockConnection);
                });
                
                // Verify all messages were sent and logged
                expect(mockConnection.sentMessages.length).toBe(5);
                messages.forEach(msg => {
                    expect(chatLog.value).toContain(`Me: ${msg}`);
                    expect(mockConnection.sentMessages).toContain(msg);
                });
                
                // Verify message order is maintained
                const chatLines = chatLog.value.split('\n').filter(line => line.startsWith('Me:'));
                expect(chatLines.length).toBe(5);
                messages.forEach((msg, index) => {
                    expect(chatLines[index]).toBe(`Me: ${msg}`);
                });
            });
            
            test('should handle incoming and outgoing messages interleaved', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Interleave sent and received messages
                sendMessage('Outgoing 1', mockConnection);
                handleReceivedMessage('Incoming 1');
                sendMessage('Outgoing 2', mockConnection);
                handleReceivedMessage('Incoming 2');
                sendMessage('Outgoing 3', mockConnection);
                
                // Verify message order and formatting
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines[0]).toBe('Me: Outgoing 1');
                expect(chatLines[1]).toBe('Peer: Incoming 1');
                expect(chatLines[2]).toBe('Me: Outgoing 2');
                expect(chatLines[3]).toBe('Peer: Incoming 2');
                expect(chatLines[4]).toBe('Me: Outgoing 3');
            });
        });
        
        describe('Edge Cases and Error Scenarios Integration Tests', () => {
            test('should handle connection failure during message sending', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up connection that will fail
                const mockConnection = {
                    open: true,
                    send: function(data) { 
                        // Simulate connection failure during send
                        this.open = false;
                        throw new Error('Connection lost');
                    },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Attempt to send message
                try {
                    sendMessage('Test message', mockConnection);
                } catch (error) {
                    // Connection should handle the error gracefully
                    expect(error.message).toBe('Connection lost');
                }
                
                // Verify message was still logged locally before failure
                expect(chatLog.value).toContain('Me: Test message');
            });
            
            test('should handle peer ID input with special characters and whitespace', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                window.myId = 'test-peer';
                
                // Test with whitespace only
                peerIdInput.value = '   ';
                expect(handleConnectClick()).toBe(false);
                
                // Test with special characters
                peerIdInput.value = 'peer@#$%^&*()';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('peer@#$%^&*()');
                
                // Test with leading/trailing whitespace
                peerIdInput.value = '  valid-peer-id  ';
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('valid-peer-id');
            });
            
            test('should handle very long messages', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Create a very long message (1000 characters)
                const longMessage = 'A'.repeat(1000);
                
                sendMessage(longMessage, mockConnection);
                
                expect(mockConnection.lastSent).toBe(longMessage);
                expect(chatLog.value).toContain(`Me: ${longMessage}`);
                expect(chatLog.value.length).toBe(`Me: ${longMessage}\n`.length);
            });
            
            test('should handle multiple error types in sequence', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test sequence of different error types
                const errors = [
                    { type: 'peer-unavailable', message: 'Peer not found' },
                    { type: 'network', message: 'Network failed' },
                    { type: 'server-error', message: 'Server down' },
                    { message: 'Generic error' }
                ];
                
                errors.forEach(error => {
                    handlePeerError(error);
                });
                
                // Verify all error messages appear in chat log
                expect(chatLog.value).toContain('System: Peer not found - please check the peer ID and try again');
                expect(chatLog.value).toContain('System: Network error - please check your internet connection and try again');
                expect(chatLog.value).toContain('System: Server error - please try again later');
                expect(chatLog.value).toContain('System: An error occurred: Generic error');
                
                // Verify error messages are in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines.length).toBe(4);
            });
            
            test('should handle connection close during active messaging', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Set up active connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                
                // Start messaging
                sendMessage('Message before close', mockConnection);
                expect(chatLog.value).toContain('Me: Message before close');
                
                // Simulate connection close
                mockConnection._close();
                
                // Verify connection close was handled
                expect(chatLog.value).toContain('System: Connection closed');
                expect(window.connection).toBeNull();
                expect(document.getElementById('send-btn').disabled).toBe(true);
                
                // Attempt to send message after close should fail
                const messageInput = document.getElementById('message-input');
                messageInput.value = 'Message after close';
                expect(handleSendClick()).toBe(false);
            });
        });
        
        describe('UI State Consistency Integration Tests', () => {
            test('should maintain consistent button states throughout connection lifecycle', () => {
                const sendBtn = document.getElementById('send-btn');
                const connectBtn = document.getElementById('connect-btn');
                
                // Initial state
                expect(sendBtn.disabled).toBe(true);
                expect(connectBtn.disabled).toBe(false);
                
                // During connection establishment
                const mockConnection = {
                    open: false,
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                setupConnectionHandlers(mockConnection);
                
                // Connection opens
                mockConnection.open = true;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                // Connection closes
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
                expect(window.connection).toBeNull();
                
                // Should be able to connect again
                expect(connectBtn.disabled).toBe(false);
            });
            
            test('should maintain chat log consistency during all operations', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Track all operations and their expected chat log entries
                const operations = [
                    () => addSystemMessage('Peer ready'),
                    () => addSystemMessage('⚡ Connection established'),
                    () => addMessageToChat('Hello', 'me'),
                    () => addMessageToChat('Hi there', 'peer'),
                    () => addSystemMessage('Connection closed')
                ];
                
                const expectedEntries = [
                    'System: Peer ready',
                    'System: ⚡ Connection established',
                    'Me: Hello',
                    'Peer: Hi there',
                    'System: Connection closed'
                ];
                
                // Execute operations
                operations.forEach(op => op());
                
                // Verify all entries are present and in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                expect(chatLines.length).toBe(expectedEntries.length);
                
                expectedEntries.forEach((expected, index) => {
                    expect(chatLines[index]).toBe(expected);
                });
                
                // Verify chat log scrolls to bottom
                expect(chatLog.scrollTop).toBe(chatLog.scrollHeight - chatLog.clientHeight);
            });
            
            test('should handle UI updates during rapid state changes', () => {
                const chatLog = document.getElementById('chat-log');
                const sendBtn = document.getElementById('send-btn');
                chatLog.value = '';
                
                // Rapid state changes: connect → message → disconnect → connect
                const mockConnection1 = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                // First connection
                window.connection = mockConnection1;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                
                // Send message
                sendMessage('Quick message', mockConnection1);
                expect(chatLog.value).toContain('Me: Quick message');
                
                // Close connection
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
                expect(chatLog.value).toContain('System: Connection closed');
                
                // Second connection
                const mockConnection2 = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                
                window.connection = mockConnection2;
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                // Verify chat log shows both connections
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                const connectionMessages = chatLines.filter(line => line.includes('Connection established'));
                expect(connectionMessages.length).toBe(2);
            });
            
            test('should maintain input field states during all operations', () => {
                const peerIdInput = document.getElementById('peer-id-input');
                const messageInput = document.getElementById('message-input');
                
                // Test peer ID input persistence
                peerIdInput.value = 'test-peer-123';
                expect(peerIdInput.value).toBe('test-peer-123');
                
                // Input should persist through connection attempts
                window.myId = 'my-peer';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                handleConnectClick();
                expect(peerIdInput.value).toBe('test-peer-123'); // Should not be cleared
                
                // Test message input clearing after send
                messageInput.value = 'Test message';
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                handleSendClick();
                expect(messageInput.value).toBe(''); // Should be cleared after send
            });
        });
        
        describe('Real User Interaction Simulation Tests', () => {
            test('should simulate complete user session with Enter key usage', () => {
                const chatLog = document.getElementById('chat-log');
                const messageInput = document.getElementById('message-input');
                chatLog.value = '';
                
                // Set up connection
                const mockConnection = {
                    open: true,
                    send: function(data) { this.sentMessages = this.sentMessages || []; this.sentMessages.push(data); },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                
                // Simulate user typing and pressing Enter
                const messages = ['Hello!', 'How are you?', 'Great to chat!'];
                
                messages.forEach(msg => {
                    messageInput.value = msg;
                    const enterEvent = {
                        key: 'Enter',
                        preventDefault: function() { this.defaultPrevented = true; }
                    };
                    
                    handleMessageInputKeyPress(enterEvent);
                    
                    expect(enterEvent.defaultPrevented).toBe(true);
                    expect(messageInput.value).toBe('');
                    expect(chatLog.value).toContain(`Me: ${msg}`);
                });
                
                expect(mockConnection.sentMessages.length).toBe(3);
                expect(mockConnection.sentMessages).toContain('Hello!');
                expect(mockConnection.sentMessages).toContain('How are you?');
                expect(mockConnection.sentMessages).toContain('Great to chat!');
            });
            
            test('should simulate user attempting invalid operations', () => {
                const chatLog = document.getElementById('chat-log');
                const peerIdInput = document.getElementById('peer-id-input');
                const messageInput = document.getElementById('message-input');
                chatLog.value = '';
                
                // Attempt to send message without connection
                messageInput.value = 'Message without connection';
                expect(handleSendClick()).toBe(false);
                expect(chatLog.value).toContain('System: Not connected to any peer');
                
                // Attempt to connect with empty peer ID
                peerIdInput.value = '';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                
                // Attempt self-connection
                window.myId = 'my-peer-id';
                peerIdInput.value = 'my-peer-id';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                // Verify all error messages are in chat log
                const errorMessages = chatLog.value.split('\n').filter(line => line.includes('System:'));
                expect(errorMessages.length).toBe(3);
            });
            
            test('should simulate user recovering from errors', () => {
                const chatLog = document.getElementById('chat-log');
                const peerIdInput = document.getElementById('peer-id-input');
                chatLog.value = '';
                
                // Start with error condition
                window.myId = 'my-peer';
                peerIdInput.value = 'my-peer';
                expect(handleConnectClick()).toBe(false);
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                // User corrects the error
                peerIdInput.value = 'valid-peer-id';
                const mockPeer = {
                    connect: function(peerId) {
                        return {
                            peer: peerId,
                            open: false,
                            on: function(event, handler) { this['_' + event] = handler; }
                        };
                    }
                };
                window.peer = mockPeer;
                
                expect(handleConnectClick()).toBe(true);
                expect(window.connection.peer).toBe('valid-peer-id');
                
                // Simulate successful connection
                handleConnectionOpen();
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                expect(document.getElementById('send-btn').disabled).toBe(false);
            });
        });
        
        describe('System Message Verification Tests', () => {
            test('should display all required system messages in correct scenarios', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test peer ready message
                addSystemMessage('Your ID is ready; share it with your peer.');
                expect(chatLog.value).toContain('System: Your ID is ready; share it with your peer.');
                
                // Test connection established message
                addSystemMessage('⚡ Connection established');
                expect(chatLog.value).toContain('System: ⚡ Connection established');
                
                // Test connection closed message
                addSystemMessage('Connection closed');
                expect(chatLog.value).toContain('System: Connection closed');
                
                // Test error messages
                addSystemMessage('Please enter a peer ID to connect');
                expect(chatLog.value).toContain('System: Please enter a peer ID to connect');
                
                addSystemMessage('Cannot connect to yourself');
                expect(chatLog.value).toContain('System: Cannot connect to yourself');
                
                addSystemMessage('Not connected to any peer');
                expect(chatLog.value).toContain('System: Not connected to any peer');
                
                // Verify all messages have System: prefix
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                chatLines.forEach(line => {
                    expect(line.startsWith('System:')).toBe(true);
                });
            });
            
            test('should verify system messages appear at correct times in workflow', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Simulate complete workflow with system message verification
                
                // 1. Peer initialization
                updateMyId('test-peer-123');
                addSystemMessage('Your ID is ready; share it with your peer.');
                
                // 2. Connection establishment
                const mockConnection = {
                    open: true,
                    send: function(data) { this.lastSent = data; },
                    on: function(event, handler) { this['_' + event] = handler; }
                };
                window.connection = mockConnection;
                handleConnectionOpen();
                
                // 3. Message exchange (no system messages)
                sendMessage('Hello', mockConnection);
                handleReceivedMessage('Hi back');
                
                // 4. Connection closure
                handleConnectionClose();
                
                // Verify system messages appear in correct order
                const chatLines = chatLog.value.split('\n').filter(line => line.trim());
                const systemMessages = chatLines.filter(line => line.startsWith('System:'));
                
                expect(systemMessages.length).toBe(3);
                expect(systemMessages[0]).toBe('System: Your ID is ready; share it with your peer.');
                expect(systemMessages[1]).toBe('System: ⚡ Connection established');
                expect(systemMessages[2]).toBe('System: Connection closed');
                
                // Verify user messages are interspersed correctly
                expect(chatLines[2]).toBe('Me: Hello');
                expect(chatLines[3]).toBe('Peer: Hi back');
            });
        });
        
        describe('Test Coverage Verification Tests', () => {
            test('should verify all major functions are tested', () => {
                const requiredFunctions = [
                    'addSystemMessage', 'updateMyId', 'validatePeerIdInput', 'validateSelfConnection',
                    'handleConnectionError', 'handlePeerError', 'handleConnectClick', 'initiateConnection',
                    'handleIncomingConnection', 'setupConnectionHandlers', 'handleConnectionOpen',
                    'enableSendButton', 'disableSendButton', 'handleConnectionClose', 'cleanupConnection',
                    'handleSendClick', 'sendMessage', 'handleReceivedMessage', 'addMessageToChat',
                    'handleMessageInputKeyPress', 'initializePeer', 'setupEventListeners'
                ];
                
                requiredFunctions.forEach(funcName => {
                    expect(typeof window[funcName]).toBe('function');
                });
            });
            
            test('should verify all DOM elements are accessible', () => {
                const requiredElements = [
                    'my-id', 'peer-id-input', 'connect-btn', 'chat-log', 'message-input', 'send-btn'
                ];
                
                requiredElements.forEach(elementId => {
                    const element = document.getElementById(elementId);
                    expect(element).not.toBeNull();
                });
            });
            
            test('should verify all error handling paths are covered', () => {
                const chatLog = document.getElementById('chat-log');
                chatLog.value = '';
                
                // Test all error types
                const errorTypes = [
                    { type: 'peer-unavailable', handler: handlePeerError },
                    { type: 'network', handler: handlePeerError },
                    { type: 'server-error', handler: handlePeerError },
                    { type: 'peer-unavailable', handler: handleConnectionError },
                    { type: 'network', handler: handleConnectionError }
                ];
                
                errorTypes.forEach(({ type, handler }) => {
                    const error = { type, message: `Test ${type} error` };
                    handler(error);
                });
                
                // Verify all error messages appear
                expect(chatLog.value).toContain('Peer not found');
                expect(chatLog.value).toContain('Network error');
                expect(chatLog.value).toContain('Server error');
                expect(chatLog.value).toContain('Connection failed: Peer not found');
                expect(chatLog.value).toContain('Connection failed: Network error');
            });
            
            test('should verify all UI state transitions are covered', () => {
                const sendBtn = document.getElementById('send-btn');
                
                // Test all button state transitions
                expect(sendBtn.disabled).toBe(true); // Initial state
                
                enableSendButton();
                expect(sendBtn.disabled).toBe(false);
                
                disableSendButton();
                expect(sendBtn.disabled).toBe(true);
                
                // Test through connection lifecycle
                handleConnectionOpen();
                expect(sendBtn.disabled).toBe(false);
                
                handleConnectionClose();
                expect(sendBtn.disabled).toBe(true);
            });
        });
        
        // ===== APPLICATION VARIABLES =====
        
        let peer = null;
        let connection = null;
        let myId = null;
        
        // Expose variables globally for testing
        window.peer = peer;
        window.connection = connection;
        window.myId = myId;
        
        // ===== HELPER FUNCTIONS =====
        
        /**
         * Adds a system message to the chat log
         * @param {string} message - The system message to display
         */
        function addSystemMessage(message) {
            addMessageToChat(message, 'system');
        }
        
        /**
         * Updates the displayed peer ID and stores it globally
         * @param {string} id - The peer ID to display and store
         */
        function updateMyId(id) {
            const myIdElement = document.getElementById('my-id');
            myIdElement.textContent = id;
            myId = id;
            window.myId = id; // Update global for testing
        }
        
        // ===== INPUT VALIDATION FUNCTIONS =====
        
        /**
         * Validates that a peer ID input is not empty or whitespace-only
         * @param {string} peerId - The peer ID to validate
         * @returns {boolean} True if peer ID is valid, false otherwise
         */
        function validatePeerIdInput(peerId) {
            return peerId && peerId.trim().length > 0;
        }
        
        /**
         * Validates that the target peer ID is not the same as the current peer's ID
         * @param {string} targetPeerId - The peer ID to connect to
         * @returns {boolean} True if connection is allowed, false if self-connection
         */
        function validateSelfConnection(targetPeerId) {
            return targetPeerId !== myId;
        }
        
        // ===== ERROR HANDLING FUNCTIONS =====
        
        /**
         * Handles connection-specific errors and displays user-friendly messages
         * @param {Object} error - The error object containing type and message
         * @param {string} error.type - The type of error (peer-unavailable, network, etc.)
         * @param {string} error.message - The error message
         */
        function handleConnectionError(error) {
            let userMessage;
            
            switch (error.type) {
                case 'peer-unavailable':
                    userMessage = 'Connection failed: Peer not found or unavailable';
                    break;
                case 'network':
                    userMessage = 'Connection failed: Network error - please check your internet connection';
                    break;
                default:
                    userMessage = `Connection failed: ${error.message || 'Unknown error'}`;
            }
            
            addSystemMessage(userMessage);
        }
        
        /**
         * Handles PeerJS-specific errors and displays user-friendly messages
         * @param {Object} error - The PeerJS error object
         * @param {string} error.type - The type of PeerJS error
         * @param {string} error.message - The error message from PeerJS
         */
        function handlePeerError(error) {
            let userMessage;
            
            switch (error.type) {
                case 'peer-unavailable':
                    userMessage = 'Peer not found - please check the peer ID and try again';
                    break;
                case 'network':
                    userMessage = 'Network error - please check your internet connection and try again';
                    break;
                case 'server-error':
                    userMessage = 'Server error - please try again later';
                    break;
                default:
                    userMessage = `An error occurred: ${error.message || 'Unknown error'}`;
            }
            
            addSystemMessage(userMessage);
        }
        
        // ===== CONNECTION ESTABLISHMENT FUNCTIONS =====
        
        /**
         * Handles the connect button click event with validation and connection initiation
         * @returns {boolean} True if connection attempt was initiated, false if validation failed
         */
        function handleConnectClick() {
            const peerIdInput = document.getElementById('peer-id-input');
            const targetPeerId = peerIdInput.value.trim();
            
            // Validate peer ID input
            if (!validatePeerIdInput(targetPeerId)) {
                addSystemMessage('Please enter a peer ID to connect');
                return false;
            }
            
            // Prevent self-connection
            if (!validateSelfConnection(targetPeerId)) {
                addSystemMessage('Cannot connect to yourself');
                return false;
            }
            
            // Initiate connection
            initiateConnection(targetPeerId);
            return true;
        }
        
        /**
         * Initiates an outgoing connection to a specified peer
         * @param {string} peerId - The ID of the peer to connect to
         * @returns {Object|null} The connection object or null if peer not initialized
         */
        function initiateConnection(peerId) {
            if (!peer) {
                addSystemMessage('Peer not initialized');
                return null;
            }
            
            // Create connection to target peer
            const conn = peer.connect(peerId);
            
            // Store connection globally
            connection = conn;
            window.connection = conn;
            
            // Setup connection event handlers
            setupConnectionHandlers(conn);
            
            return conn;
        }
        
        /**
         * Handles incoming connection requests from other peers
         * @param {Object} conn - The incoming connection object from PeerJS
         */
        function handleIncomingConnection(conn) {
            // Store the incoming connection
            connection = conn;
            window.connection = conn;
            
            // Setup connection event handlers
            setupConnectionHandlers(conn);
        }
        
        /**
         * Sets up event handlers for a connection (both incoming and outgoing)
         * @param {Object} conn - The connection object to set up handlers for
         */
        function setupConnectionHandlers(conn) {
            // Handle connection open event
            conn.on('open', handleConnectionOpen);
            
            // Handle incoming data (messages)
            conn.on('data', function(data) {
                handleReceivedMessage(data);
            });
            
            // Handle connection close event
            conn.on('close', function() {
                handleConnectionClose();
            });
            
            // Handle connection errors
            conn.on('error', function(err) {
                console.error('Connection error:', err);
                handleConnectionError(err);
            });
        }
        
        /**
         * Handles the connection open event when a connection is successfully established
         */
        function handleConnectionOpen() {
            addSystemMessage('⚡ Connection established');
            enableSendButton();
        }
        
        /**
         * Enables the send button to allow message sending
         */
        function enableSendButton() {
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = false;
        }
        
        /**
         * Disables the send button to prevent message sending
         */
        function disableSendButton() {
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
        }
        
        // ===== CONNECTION CLOSURE FUNCTIONS =====
        
        /**
         * Handles the connection close event when a connection is terminated
         */
        function handleConnectionClose() {
            addSystemMessage('Connection closed');
            cleanupConnection();
        }
        
        /**
         * Cleans up connection state and UI when a connection ends
         */
        function cleanupConnection() {
            // Disable send button
            disableSendButton();
            
            // Clear connection reference
            connection = null;
            window.connection = null;
        }
        
        // ===== MESSAGE HANDLING FUNCTIONS =====
        
        /**
         * Handles the send button click event with validation and message sending
         * @returns {boolean} True if message was sent, false if validation failed
         */
        function handleSendClick() {
            const messageInput = document.getElementById('message-input');
            const message = messageInput.value.trim();
            
            // Validate input
            if (!message) {
                return false;
            }
            
            // Check if connected
            if (!connection || !connection.open) {
                addSystemMessage('Not connected to any peer');
                return false;
            }
            
            // Send message
            sendMessage(message, connection);
            
            // Clear input
            messageInput.value = '';
            
            return true;
        }
        
        /**
         * Sends a message through the specified connection and adds it to chat log
         * @param {string} message - The message text to send
         * @param {Object} conn - The connection object to send the message through
         */
        function sendMessage(message, conn) {
            // Send message through connection
            conn.send(message);
            
            // Add to chat log with "Me:" prefix
            addMessageToChat(message, 'me');
        }
        
        /**
         * Handles received messages from the connected peer
         * @param {string} message - The received message text
         */
        function handleReceivedMessage(message) {
            // Add received message to chat log with "Peer:" prefix
            addMessageToChat(message, 'peer');
        }
        
        /**
         * Adds a formatted message to the chat log with appropriate prefix
         * @param {string} message - The message text to add
         * @param {string} sender - The sender type ('me', 'peer', 'system')
         */
        function addMessageToChat(message, sender) {
            const chatLog = document.getElementById('chat-log');
            let prefix;
            
            switch (sender) {
                case 'me':
                    prefix = 'Me:';
                    break;
                case 'peer':
                    prefix = 'Peer:';
                    break;
                case 'system':
                    prefix = 'System:';
                    break;
                default:
                    prefix = 'Unknown:';
            }
            
            const formattedMessage = `${prefix} ${message}\n`;
            chatLog.value += formattedMessage;
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        
        /**
         * Handles keypress events in the message input field (Enter to send)
         * @param {KeyboardEvent} event - The keyboard event object
         */
        function handleMessageInputKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleSendClick();
            }
        }
        
        // ===== PEERJS INITIALIZATION =====
        
        /**
         * Initializes the PeerJS instance with STUN server configuration and event handlers
         */
        function initializePeer() {
            // Create PeerJS instance with Google STUN server configuration
            peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                }
            });
            
            // Store peer globally for testing
            window.peer = peer;
            
            // Handle peer 'open' event - when peer ID is ready
            peer.on('open', function(id) {
                updateMyId(id);
                addSystemMessage('Your ID is ready; share it with your peer.');
            });
            
            // Handle incoming connections
            peer.on('connection', function(conn) {
                handleIncomingConnection(conn);
            });
            
            // Handle peer errors
            peer.on('error', function(err) {
                console.error('PeerJS Error:', err);
                handlePeerError(err);
            });
        }
        
        // ===== EVENT LISTENERS SETUP =====
        
        /**
         * Sets up all DOM event listeners for user interactions
         */
        function setupEventListeners() {
            // Connect button click handler
            const connectBtn = document.getElementById('connect-btn');
            connectBtn.addEventListener('click', handleConnectClick);
            
            // Send button click handler
            const sendBtn = document.getElementById('send-btn');
            sendBtn.addEventListener('click', handleSendClick);
            
            // Message input Enter key handler
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('keypress', handleMessageInputKeyPress);
        }
        
        // ===== APPLICATION INITIALIZATION =====
        
        /**
         * Main application initialization function
         * Initializes PeerJS and sets up event listeners
         */
        function initializeApplication() {
            initializePeer();
            setupEventListeners();
        }
        
        /**
         * Initializes the test framework and displays results
         */
        function initializeTestFramework() {
            setTimeout(() => {
                // Display initial sync test results
                if (totalAsyncTests === 0) {
                    displayTestResults();
                }
            }, 100);
        }
        
        // Initialize application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                initializeApplication();
                initializeTestFramework();
            });
        } else {
            // DOM is already ready
            initializeApplication();
            initializeTestFramework();
        }
        
    </script>
</body>
</html>